!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("@kitware/vtk.js/Common/DataModel/ImageData"),require("@kitware/vtk.js/Common/Core/DataArray"),require("@cornerstonejs/core"),require("@kitware/vtk.js/Common/DataModel/Plane"),require("@kitware/vtk.js/Common/DataModel/PolyData"),require("@kitware/vtk.js/Filters/General/ContourLoopExtraction"),require("@kitware/vtk.js/Filters/Core/Cutter"),require("gl-matrix")):"function"==typeof define&&define.amd?define(["@kitware/vtk.js/Common/DataModel/ImageData","@kitware/vtk.js/Common/Core/DataArray","@cornerstonejs/core","@kitware/vtk.js/Common/DataModel/Plane","@kitware/vtk.js/Common/DataModel/PolyData","@kitware/vtk.js/Filters/General/ContourLoopExtraction","@kitware/vtk.js/Filters/Core/Cutter","gl-matrix"],t):"object"==typeof exports?exports.cornerstoneTools3D=t(require("@kitware/vtk.js/Common/DataModel/ImageData"),require("@kitware/vtk.js/Common/Core/DataArray"),require("@cornerstonejs/core"),require("@kitware/vtk.js/Common/DataModel/Plane"),require("@kitware/vtk.js/Common/DataModel/PolyData"),require("@kitware/vtk.js/Filters/General/ContourLoopExtraction"),require("@kitware/vtk.js/Filters/Core/Cutter"),require("gl-matrix")):e.cornerstoneTools3D=t(e["@kitware/vtk.js/Common/DataModel/ImageData"],e["@kitware/vtk.js/Common/Core/DataArray"],e.cornerstone3D,e["@kitware/vtk.js/Common/DataModel/Plane"],e["@kitware/vtk.js/Common/DataModel/PolyData"],e["@kitware/vtk.js/Filters/General/ContourLoopExtraction"],e["@kitware/vtk.js/Filters/Core/Cutter"],e.window)}(self,((e,t,n,o,a,r,i,s)=>(()=>{"use strict";var l,c,m={389:(e,t,n)=>{var o=n(758),a=n(283),r=n.n(a),i=n(785),s=n.n(i),l=n(699),c=n(953),m=n(864),u=n.n(m),g=n(70),p=n.n(g),f=n(336),d=n.n(f),v=n(481),h=n.n(v);const{EPSILON:y}=c.CONSTANTS;function w(e,t){return function(e,t){var n;let o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=1/0,r=o?-1/0:0,i=1/0,s=o?-1/0:0,l=1/0,c=o?-1/0:0;const m=3===(null===(n=e[0])||void 0===n?void 0:n.length);for(let t=0;t<e.length;t++){const n=e[t];var u,g;a=Math.min(n[0],a),r=Math.max(n[0],r),i=Math.min(n[1],i),s=Math.max(n[1],s),m&&(l=Math.min(null!==(u=n[2])&&void 0!==u?u:l,l),c=Math.max(null!==(g=n[2])&&void 0!==g?g:c,c))}return t?(a=Math.max(o?t[0]+y:0,a),r=Math.min(o?t[0]-y:t[0]-1,r),i=Math.max(o?t[1]+y:0,i),s=Math.min(o?t[1]-y:t[1]-1,s),m&&3===t.length&&(l=Math.max(o?t[2]+y:0,l),c=Math.min(o?t[2]-y:t[2]-1,c))):o||(a=Math.max(0,a),r=Math.min(1/0,r),i=Math.max(0,i),s=Math.min(1/0,s),m&&(l=Math.max(0,l),c=Math.min(1/0,c))),m?[[a,r],[i,s],[l,c]]:[[a,r],[i,s],null]}(e,t,!0)}var x=n(976);function D(e,t,n,o){let a,r,i,s,l,c,m;const{numComps:u}=e;if(m=e.getScalarData?e.getScalarData():e.getPointData().getScalars().getData(),!m)return void console.warn("No scalar data found for imageData",e);const g=e.getDimensions();o?[[a,r],[i,s],[l,c]]=o:(a=0,r=g[0],i=0,s=g[1],l=0,c=g[2]);const p=x.vec3.fromValues(a,i,l),f=e.getDirection(),d=f.slice(0,3),v=f.slice(3,6),h=f.slice(6,9),y=e.getSpacing(),[w,D,I]=y,k=e.indexToWorld(p),S=x.vec3.fromValues(d[0]*w,d[1]*w,d[2]*w),P=x.vec3.fromValues(v[0]*D,v[1]*D,v[2]*D),M=x.vec3.fromValues(h[0]*I,h[1]*I,h[2]*I),C=u||m.length/g[2]/g[1]/g[0],j=g[0]*C,b=g[1]*j,V=[],A=x.vec3.clone(k);for(let e=l;e<=c;e++){const o=x.vec3.clone(A);for(let o=i;o<=s;o++){const i=x.vec3.clone(A);for(let i=a;i<=r;i++){const a=[i,o,e];if(t(A,a)){const t=e*b+o*j+i*C;let r;r=C>2?[m[t],m[t+1],m[t+2]]:m[t],V.push({value:r,index:t,pointIJK:a,pointLPS:A.slice()}),n&&n({value:r,index:t,pointIJK:a,pointLPS:A})}x.vec3.add(A,A,S)}x.vec3.copy(A,i),x.vec3.add(A,A,P)}x.vec3.copy(A,o),x.vec3.add(A,A,M)}return V}function I(e){let t;const n=c.utilities.getRandomSampleFromArray(e,50);for(let e=0;e<3;e++)if(n.every(((t,n,o)=>Math.abs(t[e]-o[0][e])<1e-6))){t=e;break}if(void 0===t)throw new Error("Cannot find a shared dimension index for polyline, probably oblique plane");const o=[],a=(t+1)%3,r=(t+2)%3;for(let t=0;t<e.length;t++)o.push([e[t][a],e[t][r]]);return{sharedDimensionIndex:t,projectedPolyline:o}}function k(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{closed:void 0};if(e.length<3)return!1;const o=e.length;let a=0;const{closed:r,holes:i}=n;if(null!=i&&i.length)for(const e of i)if(k(e,t))return!1;const s=!(void 0===r?function(e){if(e.length<3)return!1;const t=e.length,n=function(e,t){if(e.length!==t.length)throw Error("Both points should have the same dimensionality");const[n,o,a=0]=e,[r,i,s=0]=t,l=r-n,c=i-o,m=s-a;return l*l+c*c+m*m}(e[0],e[t-1]);return x.glMatrix.equals(0,n)}(e):r),l=e.length-(s?1:2);for(let n=0;n<=l;n++){const r=e[n],i=e[n===o-1?0:n+1],s=r[0]>=i[0]?r[0]:i[0],l=r[1]>=i[1]?r[1]:i[1],c=r[1]<=i[1]?r[1]:i[1];if(t[0]<=s&&t[1]>=c&&t[1]<l){let e=r[0]===i[0];if(!e){const n=(t[1]-r[1])*(i[0]-r[0])/(i[1]-r[1])+r[0];e=t[0]<=n}a+=e?1:0}}return!!(a%2)}function S(e,t){let n=e;const o=(null==t?void 0:t.numDimensions)||2,a=3===o;if(!Array.isArray(e[0])){const t=e,r=t.length/o;n=new Array(t.length/o);for(let e=0,i=r;e<i;e++)n[e]=[t[e*o],t[e*o+1]],a&&n[e].push(t[e*o+2])}let r=1/0,i=1/0,s=-1/0,l=-1/0,c=1/0,m=-1/0;for(let e=0,t=n.length;e<t;e++){const[t,o,u]=n[e];r=r<t?r:t,i=i<o?i:o,s=s>t?s:t,l=l>o?l:o,a&&(c=c<u?c:u,m=m>u?m:u)}return a?{minX:r,maxX:s,minY:i,maxY:l,minZ:c,maxZ:m}:{minX:r,maxX:s,minY:i,maxY:l}}const P=(e,t,n,o,a,r,i,s)=>{const l=[x.vec3.fromValues(n,o,a),x.vec3.fromValues(r,o,a),x.vec3.fromValues(n,i,a),x.vec3.fromValues(r,i,a),x.vec3.fromValues(n,o,s),x.vec3.fromValues(r,o,s),x.vec3.fromValues(n,i,s),x.vec3.fromValues(r,i,s)],c=x.vec3.fromValues(t[0],t[1],t[2]),m=x.vec3.fromValues(e[0],e[1],e[2]),u=-x.vec3.dot(c,m);let g=null;for(const e of l){const t=x.vec3.dot(c,e)+u;if(null===g)g=Math.sign(t);else if(Math.sign(t)!==g)return!0}return!1},M={polySeg:null,polySegInitializing:!1,polySegInitializingPromise:null,async initializePolySeg(e){var t;this.polySegInitializing?await this.polySegInitializingPromise:null!==(t=this.polySeg)&&void 0!==t&&t.instance||(this.polySegInitializing=!0,this.polySegInitializingPromise=new Promise((t=>{this.polySeg=new l.Z,this.polySeg.initialize({updateProgress:e}).then((()=>{this.polySegInitializing=!1,t()}))})),await this.polySegInitializingPromise)},async convertContourToSurface(e){const{polylines:t,numPointsArray:n}=e;for(var o=arguments.length,a=new Array(o>1?o-1:0),r=1;r<o;r++)a[r-1]=arguments[r];const[i]=a;return await this.initializePolySeg(i),await this.polySeg.instance.convertContourRoiToSurface(t,n)},async convertLabelmapToSurface(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const[a]=n;return await this.initializePolySeg(a),this.polySeg.instance.convertLabelmapToSurface(e.scalarData,e.dimensions,e.spacing,e.direction,e.origin,[e.segmentIndex])},async convertContourToVolumeLabelmap(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const[a]=n,i=await new l.Z;await i.initialize({updateProgress:a});const{segmentIndices:m,scalarData:u,annotationUIDsInSegmentMap:g,dimensions:p,origin:f,direction:d,spacing:v}=e,h=c.utilities.VoxelManager.createVolumeVoxelManager(p,u),y=r().newInstance();y.setDimensions(p),y.setOrigin(f),y.setDirection(d),y.setSpacing(v);const x=s().newInstance({name:"Pixels",numberOfComponents:1,values:u});y.getPointData().setScalars(x),y.modified();for(const e of m){const t=g.get(e);for(const n of t){if(!n.polyline)continue;const{polyline:t,holesPolyline:o}=n,a=w(t),[r,i,s]=c.utilities.transformWorldToIndex(y,[a[0][0],a[1][0],a[2][0]]),[l,m,u]=c.utilities.transformWorldToIndex(y,[a[0][1],a[1][1],a[2][1]]),{projectedPolyline:g,sharedDimensionIndex:p}=I(t),f=null==o?void 0:o.map((e=>{const{projectedPolyline:t}=I(e);return t})),d=(p+1)%3,v=(p+2)%3;D(y,(e=>{const t=[e[d],e[v]];return k(g,t,{holes:f})}),(t=>{let{pointIJK:n}=t;h.setAtIJKPoint(n,e)}),[[r,l],[i,m],[s,u]])}}return h.scalarData},async convertContourToStackLabelmap(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const[a]=n,i=await new l.Z;await i.initialize({updateProgress:a});const{segmentationsInfo:m,annotationUIDsInSegmentMap:u,segmentIndices:g}=e,p=new Map;m.forEach(((e,t)=>{const{dimensions:n,scalarData:o,direction:a,spacing:i,origin:l}=e,m=c.utilities.VoxelManager.createVolumeVoxelManager(n,o),u=r().newInstance();u.setDimensions(n),u.setOrigin(l),u.setDirection(a),u.setSpacing(i);const g=s().newInstance({name:"Pixels",numberOfComponents:1,values:o});u.getPointData().setScalars(g),u.modified(),p.set(t,{manager:m,imageData:u})}));for(const e of g){const t=u.get(e);for(const n of t){if(!n.polyline)continue;const{polyline:t,holesPolyline:o,referencedImageId:a}=n,r=w(t),{manager:i,imageData:s}=p.get(a),[l,m,u]=c.utilities.transformWorldToIndex(s,[r[0][0],r[1][0],r[2][0]]),[g,f,d]=c.utilities.transformWorldToIndex(s,[r[0][1],r[1][1],r[2][1]]),{projectedPolyline:v,sharedDimensionIndex:h}=I(t),y=null==o?void 0:o.map((e=>{const{projectedPolyline:t}=I(e);return t})),x=(h+1)%3,S=(h+2)%3;D(s,(e=>{const t=[e[x],e[S]];return k(v,t,{holes:y})}),(t=>{let{pointIJK:n}=t;i.setAtIJKPoint(n,e)}),[[l,g],[m,f],[u,d]])}}return m.forEach(((e,t)=>{const{manager:n}=p.get(t);e.scalarData=n.scalarData})),m},async convertSurfaceToVolumeLabelmap(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const[a]=n;return await this.initializePolySeg(a),this.polySeg.instance.convertSurfaceToLabelmap(e.points,e.polys,e.dimensions,e.spacing,e.direction,e.origin)},async convertSurfacesToVolumeLabelmap(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),o=1;o<t;o++)n[o-1]=arguments[o];const[a]=n;await this.initializePolySeg(a);const{segmentsInfo:i}=e,l=Array.from(i.keys()).map((t=>{const{points:n,polys:o}=i.get(t);return{...this.polySeg.instance.convertSurfaceToLabelmap(n,o,e.dimensions,e.spacing,e.direction,e.origin),segmentIndex:t}})),m=await Promise.all(l),u=r().newInstance();u.setDimensions(e.dimensions),u.setOrigin(e.origin),u.setSpacing(e.spacing),u.setDirection(e.direction);const g=e.dimensions[0]*e.dimensions[1]*e.dimensions[2],p=s().newInstance({name:"Pixels",numberOfComponents:1,values:new Uint8Array(g)});u.getPointData().setScalars(p),u.modified();const f=c.utilities.VoxelManager.createVolumeVoxelManager(e.dimensions,u.getPointData().getScalars().getData()),d=m.map((e=>{const{data:t,dimensions:n,direction:o,origin:a,spacing:i}=e,l=r().newInstance();l.setDimensions(n),l.setOrigin(a),l.setSpacing(i),l.setDirection(o);const m=s().newInstance({name:"Pixels",numberOfComponents:1,values:t});l.getPointData().setScalars(m),l.modified();const u=c.utilities.VoxelManager.createVolumeVoxelManager(n,t),g=l.getExtent();return{volume:l,voxelManager:u,extent:g,scalarData:t,segmentIndex:e.segmentIndex}}));return D(u,(()=>!0),(e=>{let{pointIJK:t,pointLPS:n}=e;try{for(const e of d){const{volume:o,extent:a,voxelManager:r,segmentIndex:i}=e,s=o.worldToIndex(n);if(s[0]<a[0]||s[0]>a[1]||s[1]<a[2]||s[1]>a[3]||s[2]<a[4]||s[2]>a[5])continue;const l=s.map(Math.round);if(r.getAtIJK(...l)>0){f.setAtIJKPoint(t,i);break}}}catch(e){}})),f.scalarData},getSurfacesAABBs(e){let{surfacesInfo:t}=e;const n=new Map;for(const{points:e,id:o}of t){const t=S(e,{numDimensions:3});n.set(o,t)}return n},cutSurfacesIntoPlanes(e,t,n){let{planesInfo:o,surfacesInfo:a,surfacesAABB:r=new Map}=e;const i=o.length,s=h().newInstance(),l=u().newInstance();s.setCutFunction(l);const c=p().newInstance();try{for(const[e,m]of o.entries()){const{sliceIndex:o,planes:u}=m,g=new Map;for(const e of a){const{points:t,polys:n,id:o}=e,a=r.get(o)||S(t,{numDimensions:3});r.has(o)||r.set(o,a);const{minX:i,minY:m,minZ:p,maxX:f,maxY:v,maxZ:h}=a,{origin:y,normal:w}=u[0];if(!P(y,w,i,m,p,f,v,h))continue;c.getPoints().setData(t,3),c.getPolys().setData(n,3),c.modified(),s.setInputData(c),l.setOrigin(y),l.setNormal(w);try{s.update()}catch(e){console.warn("Error during clipping",e);continue}const x=s.getOutputData(),D=x;D.buildLinks();const I=d().newInstance();I.setInputData(D);const k=I.getOutputData();x&&g.set(o,{points:k.getPoints().getData(),lines:k.getLines().getData(),numberOfCells:k.getLines().getNumberOfCells()})}t({progress:(e+1)/i}),n({sliceIndex:o,polyDataResults:g})}}catch(e){console.warn("Error during processing",e)}finally{a=null,l.delete()}}};(0,o.Jj)(M)},785:e=>{e.exports=t},283:t=>{t.exports=e},864:e=>{e.exports=o},70:e=>{e.exports=a},481:e=>{e.exports=i},336:e=>{e.exports=r},953:e=>{e.exports=n},976:e=>{e.exports=s}},u={};function g(e){var t=u[e];if(void 0!==t)return t.exports;var n=u[e]={exports:{}};return m[e](n,n.exports,g),n.exports}return g.m=m,g.x=()=>{var e=g.O(void 0,[78],(()=>g(389)));return g.O(e)},l=[],g.O=(e,t,n,o)=>{if(!t){var a=1/0;for(c=0;c<l.length;c++){t=l[c][0],n=l[c][1],o=l[c][2];for(var r=!0,i=0;i<t.length;i++)(!1&o||a>=o)&&Object.keys(g.O).every((e=>g.O[e](t[i])))?t.splice(i--,1):(r=!1,o<a&&(a=o));if(r){l.splice(c--,1);var s=n();void 0!==s&&(e=s)}}return e}o=o||0;for(var c=l.length;c>0&&l[c-1][2]>o;c--)l[c]=l[c-1];l[c]=[t,n,o]},g.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return g.d(t,{a:t}),t},g.d=(e,t)=>{for(var n in t)g.o(t,n)&&!g.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},g.f={},g.e=e=>Promise.all(Object.keys(g.f).reduce(((t,n)=>(g.f[n](e,t),t)),[])),g.u=e=>e+".index.js",g.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),g.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;g.g.importScripts&&(e=g.g.location+"");var t=g.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var o=n.length-1;o>-1&&!e;)e=n[o--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),g.p=e})(),(()=>{var e={985:1};g.f.i=(t,n)=>{e[t]||importScripts(g.p+g.u(t))};var t=self.webpackChunkcornerstoneTools3D=self.webpackChunkcornerstoneTools3D||[],n=t.push.bind(t);t.push=t=>{var o=t[0],a=t[1],r=t[2];for(var i in a)g.o(a,i)&&(g.m[i]=a[i]);for(r&&r(g);o.length;)e[o.pop()]=1;n(t)}})(),c=g.x,g.x=()=>g.e(78).then(c),g.x()})()));
//# sourceMappingURL=985.index.js.map