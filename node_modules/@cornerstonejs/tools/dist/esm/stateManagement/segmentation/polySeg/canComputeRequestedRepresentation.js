import { SegmentationRepresentations } from '../../../enums';
import { validateLabelmap } from '../../../tools/displayTools/Labelmap';
import { findSegmentationRepresentationByUID, getSegmentation, } from '../segmentationState';
const conversionPaths = new Map([
    [
        SegmentationRepresentations.Labelmap,
        new Set([
            SegmentationRepresentations.Surface,
            SegmentationRepresentations.Contour,
        ]),
    ],
    [
        SegmentationRepresentations.Contour,
        new Set([
            SegmentationRepresentations.Labelmap,
            SegmentationRepresentations.Surface,
        ]),
    ],
    [
        SegmentationRepresentations.Surface,
        new Set([SegmentationRepresentations.Labelmap]),
    ],
]);
function canComputeRequestedRepresentation(segmentationRepresentationUID) {
    const representationInfo = findSegmentationRepresentationByUID(segmentationRepresentationUID);
    if (!representationInfo?.segmentationRepresentation) {
        return false;
    }
    const { segmentationRepresentation } = representationInfo;
    const { type: representationType, polySeg } = segmentationRepresentation;
    if (!polySeg || !polySeg.enabled) {
        return false;
    }
    const { representationData } = getSegmentation(segmentationRepresentation.segmentationId);
    const existingRepresentationTypes = getExistingRepresentationTypes(representationData);
    return existingRepresentationTypes.some((existingRepresentationType) => canConvertFromTo(existingRepresentationType, representationType));
}
function getExistingRepresentationTypes(representationData) {
    const supportedTypes = [];
    Object.keys(representationData).forEach((representationType) => {
        const representationTypeData = representationData[representationType];
        let validateFn;
        switch (representationType) {
            case SegmentationRepresentations.Labelmap:
                validateFn = validateLabelmap;
                break;
        }
        if (validateFn) {
            try {
                validateFn(representationTypeData);
                supportedTypes.push(representationType);
            }
            catch (error) {
                console.warn(`Validation failed for labelmap of type ${representationType}`);
            }
        }
        else {
            supportedTypes.push(representationType);
        }
    });
    return supportedTypes;
}
async function canConvertFromTo(fromRepresentationType, toRepresentationType) {
    return (conversionPaths.get(fromRepresentationType)?.has(toRepresentationType) ||
        false);
}
export { canComputeRequestedRepresentation };
//# sourceMappingURL=canComputeRequestedRepresentation.js.map