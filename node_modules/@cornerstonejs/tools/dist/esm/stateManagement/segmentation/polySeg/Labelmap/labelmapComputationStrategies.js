import { VolumeViewport, volumeLoader, utilities } from '@cornerstonejs/core';
import { getUniqueSegmentIndices } from '../../../../utilities/segmentation';
import { getSegmentation } from '../../segmentationState';
import { convertContourToStackLabelmap, convertContourToVolumeLabelmap, } from './convertContourToLabelmap';
import { convertSurfaceToVolumeLabelmap } from './convertSurfaceToLabelmap';
import { computeStackSegmentationFromVolume } from '../../convertVolumeToStackSegmentation';
export async function computeLabelmapData(segmentationId, options = {}) {
    const segmentIndices = options.segmentIndices?.length
        ? options.segmentIndices
        : getUniqueSegmentIndices(segmentationId);
    let rawLabelmapData;
    const segmentation = getSegmentation(segmentationId);
    const representationData = segmentation.representationData;
    try {
        if (representationData.CONTOUR) {
            rawLabelmapData = await computeLabelmapFromContourSegmentation(segmentationId, {
                segmentIndices,
                ...options,
            });
        }
        else if (representationData.SURFACE) {
            rawLabelmapData = await computeLabelmapFromSurfaceSegmentation(segmentation.segmentationId, {
                segmentIndices,
                ...options,
            });
        }
    }
    catch (error) {
        console.error(error);
        throw error;
    }
    if (!rawLabelmapData) {
        throw new Error('Not enough data to convert to surface, currently only support converting volume labelmap to surface if available');
    }
    return rawLabelmapData;
}
async function computeLabelmapFromContourSegmentation(segmentationId, options = {}) {
    const isVolume = options.viewport instanceof VolumeViewport ?? true;
    if (isVolume && !options.viewport) {
        throw new Error('Cannot compute labelmap from contour segmentation without providing the viewport');
    }
    const segmentIndices = options.segmentIndices?.length
        ? options.segmentIndices
        : getUniqueSegmentIndices(segmentationId);
    const segmentation = getSegmentation(segmentationId);
    const representationData = segmentation.representationData.CONTOUR;
    const convertFunction = isVolume
        ? convertContourToVolumeLabelmap
        : convertContourToStackLabelmap;
    const result = await convertFunction(representationData, {
        segmentIndices,
        segmentationRepresentationUID: options.segmentationRepresentationUID,
        viewport: options.viewport,
    });
    return result;
}
async function computeLabelmapFromSurfaceSegmentation(segmentationId, options = {}) {
    const isVolume = options.viewport instanceof VolumeViewport ?? true;
    const segmentIndices = options.segmentIndices?.length
        ? options.segmentIndices
        : getUniqueSegmentIndices(segmentationId);
    const segmentation = getSegmentation(segmentationId);
    const segmentsGeometryIds = new Map();
    const representationData = segmentation.representationData.SURFACE;
    representationData.geometryIds.forEach((geometryId, segmentIndex) => {
        if (segmentIndices.includes(segmentIndex)) {
            segmentsGeometryIds.set(segmentIndex, geometryId);
        }
    });
    if (isVolume && !options.viewport) {
        throw new Error('Cannot compute labelmap from surface segmentation without providing the viewport');
    }
    let segmentationVolume;
    if (isVolume) {
        const defaultActor = options.viewport.getDefaultActor();
        const { uid: volumeId } = defaultActor;
        segmentationVolume =
            await volumeLoader.createAndCacheDerivedSegmentationVolume(volumeId);
    }
    else {
        const imageIds = options.viewport.getImageIds();
        const volumeId = 'generatedSegmentationVolumeId';
        const volumeProps = utilities.generateVolumePropsFromImageIds(imageIds, volumeId);
        delete volumeProps.imageIds;
        segmentationVolume = await volumeLoader.createLocalSegmentationVolume({
            ...volumeProps,
            scalarData: volumeProps.scalarData,
            referencedImageIds: imageIds,
        }, volumeId);
    }
    const result = await convertSurfaceToVolumeLabelmap({ geometryIds: segmentsGeometryIds }, segmentationVolume);
    if (isVolume) {
        return result;
    }
    const stackData = (await computeStackSegmentationFromVolume({
        volumeId: segmentationVolume.volumeId,
    }));
    return stackData;
}
export { computeLabelmapFromContourSegmentation };
//# sourceMappingURL=labelmapComputationStrategies.js.map