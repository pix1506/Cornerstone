import { cache, utilities } from '@cornerstonejs/core';
import { SegmentationRepresentations } from '../../enums';
import { getSegmentation, getSegmentationIdRepresentations, } from '../../stateManagement/segmentation/segmentationState';
import { isVolumeSegmentation } from '../../tools/segmentation/strategies/utils/stackVolumeCheck';
import { getAnnotation } from '../../stateManagement';
import { isPointInsidePolyline3D } from '../math/polyline';
export function getSegmentAtWorldPoint(segmentationId, worldPoint, options = {}) {
    const segmentation = getSegmentation(segmentationId);
    const representationData = segmentation.representationData;
    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];
    if (!desiredRepresentation) {
        throw new Error(`Segmentation ${segmentationId} does not have any representations`);
    }
    switch (desiredRepresentation) {
        case SegmentationRepresentations.Labelmap:
            return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);
        case SegmentationRepresentations.Contour:
            return getSegmentAtWorldForContour(segmentation, worldPoint, options);
        default:
            return;
    }
}
export function getSegmentAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
    const labelmapData = segmentation.representationData.LABELMAP;
    if (isVolumeSegmentation(labelmapData)) {
        const { volumeId } = labelmapData;
        const segmentationVolume = cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        return segmentIndex;
    }
    const { imageIdReferenceMap } = labelmapData;
    const currentImageId = viewport.getCurrentImageId();
    const segmentationImageId = imageIdReferenceMap.get(currentImageId);
    const image = cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationRepresentations = getSegmentationIdRepresentations(segmentation.segmentationId);
    const { segmentationRepresentationUID } = segmentationRepresentations[0];
    const segmentationActor = viewport.getActor(segmentationRepresentationUID);
    const imageData = segmentationActor?.actor.getMapper().getInputData();
    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        utilities.VoxelManager.createVolumeVoxelManager(dimensions, imageData.getPointData().getScalars().getData()));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    return segmentIndex;
}
export function getSegmentAtWorldForContour(segmentation, worldPoint, { viewport }) {
    const contourData = segmentation.representationData.CONTOUR;
    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
    const { viewPlaneNormal } = viewport.getCamera();
    for (const segmentIndex of segmentIndices) {
        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
        if (!annotationsSet) {
            continue;
        }
        for (const annotationUID of annotationsSet) {
            const annotation = getAnnotation(annotationUID);
            if (!annotation) {
                continue;
            }
            const { polyline } = annotation.data.contour;
            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
                continue;
            }
            if (isPointInsidePolyline3D(worldPoint, polyline)) {
                return Number(segmentIndex);
            }
        }
    }
}
//# sourceMappingURL=getSegmentAtWorldPoint.js.map