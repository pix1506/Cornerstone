"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addContourSetsToElement = exports.updateContourSets = exports.handleContourSegmentation = void 0;
const stateManagement_1 = require("../../../../stateManagement");
const core_1 = require("@cornerstonejs/core");
const annotationHydration_1 = require("../../../../utilities/annotationHydration");
const contourConfigCache_1 = require("./contourConfigCache");
const utils_1 = require("./utils");
const contourSegmentation_1 = require("../../../../utilities/contourSegmentation");
const utils_2 = require("./utils");
function handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation, contourRepresentationConfig) {
    const addOrUpdateFn = annotationUIDsMap.size
        ? updateContourSets
        : addContourSetsToElement;
    addOrUpdateFn(viewport, geometryIds, contourRepresentation, contourRepresentationConfig);
}
exports.handleContourSegmentation = handleContourSegmentation;
function updateContourSets(viewport, geometryIds, contourRepresentation, contourRepresentationConfig) {
    const { segmentationRepresentationUID, segmentsHidden } = contourRepresentation;
    const newContourConfig = contourRepresentationConfig.representations.CONTOUR;
    const cachedConfig = (0, contourConfigCache_1.getConfigCache)(segmentationRepresentationUID);
    const newOutlineWithActive = newContourConfig.outlineWidthActive;
    if ((cachedConfig === null || cachedConfig === void 0 ? void 0 : cachedConfig.outlineWidthActive) !== newOutlineWithActive) {
        (0, contourConfigCache_1.setConfigCache)(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            outlineWidthActive: newOutlineWithActive,
        }));
    }
    const segmentsToSetToInvisible = [];
    const segmentsToSetToVisible = [];
    for (const segmentIndex of segmentsHidden) {
        if (!cachedConfig.segmentsHidden.has(segmentIndex)) {
            segmentsToSetToInvisible.push(segmentIndex);
        }
    }
    for (const segmentIndex of cachedConfig.segmentsHidden) {
        if (!segmentsHidden.has(segmentIndex)) {
            segmentsToSetToVisible.push(segmentIndex);
        }
    }
    const mergedInvisibleSegments = Array.from(cachedConfig.segmentsHidden)
        .filter((segmentIndex) => !segmentsToSetToVisible.includes(segmentIndex))
        .concat(segmentsToSetToInvisible);
    const { segmentSpecificConfigs } = geometryIds.reduce((acc, geometryId) => {
        const geometry = core_1.cache.getGeometry(geometryId);
        const { data: contourSet } = geometry;
        const segmentIndex = contourSet.getSegmentIndex();
        const segmentSpecificConfig = (0, utils_1.getSegmentSpecificConfig)(contourRepresentation, geometryId, segmentIndex);
        acc.segmentSpecificConfigs[segmentIndex] = segmentSpecificConfig !== null && segmentSpecificConfig !== void 0 ? segmentSpecificConfig : {};
        return acc;
    }, { contourSets: [], segmentSpecificConfigs: {} });
    const affectedSegments = [
        ...mergedInvisibleSegments,
        ...segmentsToSetToVisible,
    ];
    const hasCustomSegmentSpecificConfig = Object.values(segmentSpecificConfigs).some((config) => Object.keys(config).length > 0);
    if (affectedSegments.length || hasCustomSegmentSpecificConfig) {
        (0, contourConfigCache_1.setConfigCache)(segmentationRepresentationUID, Object.assign({}, cachedConfig, {
            segmentsHidden: new Set(segmentsHidden),
        }));
    }
    viewport.render();
}
exports.updateContourSets = updateContourSets;
function addContourSetsToElement(viewport, geometryIds, contourRepresentation, contourRepresentationConfig) {
    const { segmentationRepresentationUID, segmentationId, segmentsHidden } = contourRepresentation;
    const segmentSpecificMap = new Map();
    geometryIds.forEach((geometryId) => {
        const geometry = core_1.cache.getGeometry(geometryId);
        if (!geometry) {
            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);
            return;
        }
        const segmentIndex = geometry.data.getSegmentIndex();
        (0, utils_2.validateGeometry)(geometry);
        const segmentSpecificConfig = (0, utils_1.getSegmentSpecificConfig)(contourRepresentation, geometryId, segmentIndex);
        const contourSet = geometry.data;
        contourSet.contours.forEach((contour) => {
            const { points, color, id } = contour;
            const contourSegmentationAnnotation = {
                annotationUID: core_1.utilities.uuidv4(),
                data: {
                    contour: {
                        closed: true,
                        polyline: points,
                    },
                    segmentation: {
                        segmentationId,
                        segmentIndex,
                        color,
                        id,
                    },
                    handles: {},
                },
                handles: {},
                highlighted: false,
                autoGenerated: false,
                invalidated: false,
                isLocked: true,
                isVisible: true,
                metadata: {
                    referencedImageId: (0, annotationHydration_1.getClosestImageIdForStackViewport)(viewport, points[0], viewport.getCamera().viewPlaneNormal),
                    toolName: 'PlanarFreehandContourSegmentationTool',
                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),
                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,
                },
            };
            const annotationGroupSelector = viewport.element;
            (0, stateManagement_1.addAnnotation)(contourSegmentationAnnotation, annotationGroupSelector);
            (0, contourSegmentation_1.addContourSegmentationAnnotation)(contourSegmentationAnnotation);
        });
        if (segmentSpecificConfig) {
            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);
        }
    });
    const outlineWidthActive = contourRepresentationConfig.representations.CONTOUR.outlineWidthActive;
    (0, contourConfigCache_1.setConfigCache)(segmentationRepresentationUID, Object.assign({}, (0, contourConfigCache_1.getConfigCache)(segmentationRepresentationUID), {
        segmentsHidden: new Set(segmentsHidden),
        segmentSpecificMap,
        outlineWidthActive,
    }));
    viewport.resetCamera();
    viewport.render();
}
exports.addContourSetsToElement = addContourSetsToElement;
//# sourceMappingURL=handleContourSegmentation.js.map