"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeContourFromLabelmapSegmentation = exports.computeContourData = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentation_1 = require("../../../../utilities/segmentation");
const segmentationState_1 = require("../../segmentationState");
const surfaceComputationStrategies_1 = require("../Surface/surfaceComputationStrategies");
const clipAndCacheSurfacesForViewport_1 = require("../../helpers/clipAndCacheSurfacesForViewport");
const extractContourData_1 = require("./utils/extractContourData");
const createAndAddContourSegmentationsFromClippedSurfaces_1 = require("./utils/createAndAddContourSegmentationsFromClippedSurfaces");
const ToolGroupManager_1 = require("../../../../store/ToolGroupManager");
function computeContourData(segmentationId, options = {}) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const segmentIndices = ((_a = options.segmentIndices) === null || _a === void 0 ? void 0 : _a.length)
            ? options.segmentIndices
            : (0, segmentation_1.getUniqueSegmentIndices)(segmentationId);
        let rawContourData;
        const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
        const representationData = segmentation.representationData;
        try {
            if (representationData.SURFACE) {
                rawContourData = yield computeContourFromSurfaceSegmentation(segmentationId, Object.assign({ segmentIndices }, options));
            }
            else if (representationData.LABELMAP) {
                rawContourData = yield computeContourFromLabelmapSegmentation(segmentationId, Object.assign({ segmentIndices }, options));
            }
        }
        catch (error) {
            console.error(error);
            throw error;
        }
        if (!rawContourData) {
            throw new Error('Not enough data to convert to contour, currently only support converting volume labelmap to contour if available');
        }
        const { viewport, segmentationRepresentationUID } = options;
        const annotationUIDsMap = (0, createAndAddContourSegmentationsFromClippedSurfaces_1.createAndAddContourSegmentationsFromClippedSurfaces)(rawContourData, viewport, segmentationId);
        const toolGroupId = (_b = (0, ToolGroupManager_1.getToolGroupForViewport)(viewport.id)) === null || _b === void 0 ? void 0 : _b.id;
        (0, segmentationState_1.setSegmentationRepresentationSpecificConfig)(toolGroupId, segmentationRepresentationUID, {
            CONTOUR: {
                fillAlpha: 0,
            },
        });
        return {
            annotationUIDsMap,
        };
    });
}
exports.computeContourData = computeContourData;
function computeContourFromLabelmapSegmentation(segmentationId, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.viewport) {
            throw new Error('Viewport is required to compute contour from labelmap');
        }
        const results = yield (0, surfaceComputationStrategies_1.computeSurfaceFromLabelmapSegmentation)(segmentationId, options);
        if (!(results === null || results === void 0 ? void 0 : results.length)) {
            console.error('Failed to convert labelmap to surface or labelmap is empty');
            return;
        }
        const { viewport, segmentationRepresentationUID } = options;
        const pointsAndPolys = results.map((surface) => {
            return {
                id: surface.segmentIndex.toString(),
                points: surface.data.points,
                polys: surface.data.polys,
                segmentIndex: surface.segmentIndex,
            };
        });
        const polyDataCache = yield (0, clipAndCacheSurfacesForViewport_1.clipAndCacheSurfacesForViewport)(pointsAndPolys, viewport, segmentationRepresentationUID);
        const rawResults = (0, extractContourData_1.extractContourData)(polyDataCache);
        return rawResults;
    });
}
exports.computeContourFromLabelmapSegmentation = computeContourFromLabelmapSegmentation;
function computeContourFromSurfaceSegmentation(segmentationId, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.viewport) {
            throw new Error('Viewport is required to compute contour from surface');
        }
        const { viewport, segmentationRepresentationUID } = options;
        const segmentIndices = ((_a = options.segmentIndices) === null || _a === void 0 ? void 0 : _a.length)
            ? options.segmentIndices
            : (0, segmentation_1.getUniqueSegmentIndices)(segmentationId);
        const segmentIndexToSurfaceId = new Map();
        const surfaceIdToSegmentIndex = new Map();
        const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
        const representationData = segmentation.representationData.SURFACE;
        const surfacesInfo = [];
        representationData.geometryIds.forEach((geometryId, segmentIndex) => {
            var _a;
            if (segmentIndices.includes(segmentIndex)) {
                segmentIndexToSurfaceId.set(segmentIndex, geometryId);
                const surface = (_a = core_1.cache.getGeometry(geometryId)) === null || _a === void 0 ? void 0 : _a.data;
                if (surface) {
                    surfacesInfo.push({
                        id: geometryId,
                        points: surface.getPoints(),
                        polys: surface.getPolys(),
                    });
                }
            }
        });
        segmentIndexToSurfaceId.forEach((surfaceId, segmentIndex) => {
            surfaceIdToSegmentIndex.set(surfaceId, segmentIndex);
        });
        const polyDataCache = yield (0, clipAndCacheSurfacesForViewport_1.clipAndCacheSurfacesForViewport)(surfacesInfo, viewport, segmentationRepresentationUID);
        const rawResults = (0, extractContourData_1.extractContourData)(polyDataCache, surfaceIdToSegmentIndex);
        return rawResults;
    });
}
//# sourceMappingURL=contourComputationStrategies.js.map