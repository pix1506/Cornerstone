"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAndCacheSurfacesFromRaw = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentationColor_1 = require("../../config/segmentationColor");
const segmentationState_1 = require("../../segmentationState");
function createAndCacheSurfacesFromRaw(segmentationId, rawSurfacesData, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let segmentationRepresentation, toolGroupId;
        if (options.segmentationRepresentationUID) {
            ({ segmentationRepresentation, toolGroupId } =
                (0, segmentationState_1.findSegmentationRepresentationByUID)(options.segmentationRepresentationUID));
        }
        const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
        const geometryIds = new Map();
        const promises = Object.keys(rawSurfacesData).map((index) => __awaiter(this, void 0, void 0, function* () {
            const rawSurfaceData = rawSurfacesData[index];
            const segmentIndex = rawSurfaceData.segmentIndex;
            const color = segmentationRepresentation;
            (0, segmentationColor_1.getColorForSegmentIndex)(toolGroupId, segmentationRepresentation.segmentationRepresentationUID, segmentIndex).slice(0, 3);
            if (!color) {
                throw new Error('No color found for segment index, unable to create surface');
            }
            const closedSurface = {
                id: `segmentation_${segmentation.segmentationId}_surface_${segmentIndex}`,
                color,
                frameOfReferenceUID: 'test-frameOfReferenceUID',
                data: {
                    points: rawSurfaceData.data.points,
                    polys: rawSurfaceData.data.polys,
                },
            };
            const geometryId = closedSurface.id;
            geometryIds.set(segmentIndex, geometryId);
            return core_1.geometryLoader.createAndCacheGeometry(geometryId, {
                type: core_1.Enums.GeometryType.SURFACE,
                geometryData: closedSurface,
            });
        }));
        yield Promise.all(promises);
        return {
            geometryIds,
        };
    });
}
exports.createAndCacheSurfacesFromRaw = createAndCacheSurfacesFromRaw;
//# sourceMappingURL=createAndCacheSurfacesFromRaw.js.map