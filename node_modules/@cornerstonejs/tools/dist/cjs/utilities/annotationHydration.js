"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClosestImageIdForStackViewport = exports.annotationHydration = void 0;
const core_1 = require("@cornerstonejs/core");
const stateManagement_1 = require("../stateManagement");
const gl_matrix_1 = require("gl-matrix");
function annotationHydration(viewport, toolName, worldPoints, options) {
    const viewReference = viewport.getViewReference();
    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;
    const annotation = {
        annotationUID: (options === null || options === void 0 ? void 0 : options.annotationUID) || core_1.utilities.uuidv4(),
        data: {
            handles: {
                points: worldPoints,
            },
        },
        highlighted: false,
        autoGenerated: false,
        invalidated: false,
        isLocked: false,
        isVisible: true,
        metadata: Object.assign({ toolName,
            viewPlaneNormal,
            FrameOfReferenceUID, referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal) }, options),
    };
    (0, stateManagement_1.addAnnotation)(annotation, viewport.element);
    return annotation;
}
exports.annotationHydration = annotationHydration;
function getReferencedImageId(viewport, worldPos, viewPlaneNormal) {
    let referencedImageId;
    if (viewport instanceof core_1.StackViewport) {
        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);
    }
    else if (viewport instanceof core_1.BaseVolumeViewport) {
        const targetId = getTargetId(viewport);
        const volumeId = core_1.utilities.getVolumeId(targetId);
        const imageVolume = core_1.cache.getVolume(volumeId);
        referencedImageId = core_1.utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);
    }
    else {
        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');
    }
    return referencedImageId;
}
function getTargetId(viewport) {
    var _a;
    const targetId = (_a = viewport.getReferenceId) === null || _a === void 0 ? void 0 : _a.call(viewport);
    if (targetId) {
        return targetId;
    }
    if (viewport instanceof core_1.BaseVolumeViewport) {
        return `volumeId:${getTargetVolumeId(viewport)}`;
    }
    throw new Error('getTargetId: viewport must have a getTargetId method');
}
function getTargetVolumeId(viewport) {
    var _a;
    const actorEntries = viewport.getActors();
    if (!actorEntries) {
        return;
    }
    return (_a = actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')) === null || _a === void 0 ? void 0 : _a.uid;
}
function getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {
    const imageIds = viewport.getImageIds();
    if (!imageIds || !imageIds.length) {
        return;
    }
    const distanceImagePairs = imageIds.map((imageId) => {
        const { imagePositionPatient } = core_1.metaData.get('imagePlaneModule', imageId);
        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);
        return { imageId, distance };
    });
    distanceImagePairs.sort((a, b) => a.distance - b.distance);
    return distanceImagePairs[0].imageId;
}
exports.getClosestImageIdForStackViewport = getClosestImageIdForStackViewport;
function calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {
    const dir = gl_matrix_1.vec3.create();
    gl_matrix_1.vec3.sub(dir, worldPos, ImagePositionPatient);
    const dot = gl_matrix_1.vec3.dot(dir, viewPlaneNormal);
    return Math.abs(dot);
}
//# sourceMappingURL=annotationHydration.js.map