"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPolylineHole = void 0;
const core_1 = require("@cornerstonejs/core");
const getViewportsForAnnotation_1 = __importDefault(require("../../../utilities/getViewportsForAnnotation"));
const utilities_1 = require("../../../utilities");
const viewportFilters_1 = require("../../../utilities/viewportFilters");
const annotationState_1 = require("../../../stateManagement/annotation/annotationState");
const contourUtils = __importStar(require("../../../utilities/contours"));
const contourSegUtils = __importStar(require("../../../utilities/contourSegmentation"));
const store_1 = require("../../../store");
const tools_1 = require("../../../tools");
const ContourAnnotation_1 = require("../../../types/ContourAnnotation");
const state_1 = require("../../../stateManagement/annotation/helpers/state");
const DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';
function contourSegmentationCompletedListener(evt) {
    return __awaiter(this, void 0, void 0, function* () {
        const sourceAnnotation = evt.detail
            .annotation;
        if (!contourSegUtils.isContourSegmentationAnnotation(sourceAnnotation)) {
            return;
        }
        const viewport = getViewport(sourceAnnotation);
        const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);
        if (!contourSegmentationAnnotations.length) {
            return;
        }
        const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);
        const targetAnnotationInfo = findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations);
        if (!targetAnnotationInfo) {
            return;
        }
        const { targetAnnotation, targetPolyline, isContourHole } = targetAnnotationInfo;
        if (isContourHole) {
            const { contourHoleProcessingEnabled = false } = evt.detail;
            if (!contourHoleProcessingEnabled) {
                return;
            }
            createPolylineHole(viewport, targetAnnotation, sourceAnnotation);
        }
        else {
            combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);
        }
    });
}
exports.default = contourSegmentationCompletedListener;
function isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {
    const { toolName } = tools_1.PlanarFreehandContourSegmentationTool;
    const toolGroup = store_1.ToolGroupManager.getToolGroupForViewport(viewport.id, viewport.renderingEngineId);
    let errorMessage;
    if (!toolGroup.hasTool(toolName)) {
        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;
    }
    else if (!toolGroup.getToolOptions(toolName)) {
        errorMessage = `Tool ${toolName} must be in active/passive state`;
    }
    if (errorMessage && !silent) {
        console.warn(errorMessage);
    }
    return !errorMessage;
}
function getViewport(annotation) {
    const viewports = (0, getViewportsForAnnotation_1.default)(annotation);
    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));
    return viewportWithToolRegistered !== null && viewportWithToolRegistered !== void 0 ? viewportWithToolRegistered : viewports[0];
}
function convertContourPolylineToCanvasSpace(polyline, viewport) {
    const numPoints = polyline.length;
    const projectedPolyline = new Array(numPoints);
    for (let i = 0; i < numPoints; i++) {
        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);
    }
    return projectedPolyline;
}
function getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {
    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;
    const allAnnotations = (0, annotationState_1.getAllAnnotations)();
    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&
        targetAnnotation.annotationUID !== sourceAnnotationUID &&
        contourSegUtils.isContourSegmentationAnnotation(targetAnnotation) &&
        contourSegUtils.areSameSegment(targetAnnotation, sourceAnnotation) &&
        viewport.isReferenceViewable(targetAnnotation.metadata));
}
function findIntersectingContour(viewport, sourcePolyline, contourSegmentationAnnotations) {
    const sourceAABB = utilities_1.math.polyline.getAABB(sourcePolyline);
    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {
        const targetAnnotation = contourSegmentationAnnotations[i];
        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);
        const targetAABB = utilities_1.math.polyline.getAABB(targetPolyline);
        const aabbIntersect = utilities_1.math.aabb.intersectAABB(sourceAABB, targetAABB);
        const lineSegmentsIntersect = aabbIntersect &&
            utilities_1.math.polyline.intersectPolyline(sourcePolyline, targetPolyline);
        const isContourHole = aabbIntersect &&
            !lineSegmentsIntersect &&
            utilities_1.math.polyline.containsPoints(targetPolyline, sourcePolyline);
        if (lineSegmentsIntersect || isContourHole) {
            return { targetAnnotation, targetPolyline, isContourHole };
        }
    }
}
function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {
    const { windingDirection: targetWindingDirection } = targetAnnotation.data.contour;
    const { windingDirection: holeWindingDirection } = holeAnnotation.data.contour;
    (0, annotationState_1.addChildAnnotation)(targetAnnotation, holeAnnotation);
    contourSegUtils.removeContourSegmentationAnnotation(holeAnnotation);
    const { contour: holeContour } = holeAnnotation.data;
    const holePolyline = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);
    contourUtils.updateContourPolyline(holeAnnotation, {
        points: holePolyline,
        closed: holeContour.closed,
    }, viewport);
    const { element } = viewport;
    const enabledElement = (0, core_1.getEnabledElement)(element);
    const { renderingEngine } = enabledElement;
    const updatedToolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOLNAME,
        targetAnnotation.metadata.toolName,
        holeAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedToolNames.values()) {
        const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, toolName);
        (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
    }
}
exports.createPolylineHole = createPolylineHole;
function getContourHolesData(viewport, annotation) {
    return (0, annotationState_1.getChildAnnotations)(annotation).map((holeAnnotation) => {
        const polyline = convertContourPolylineToCanvasSpace(holeAnnotation.data.contour.polyline, viewport);
        return { annotation: holeAnnotation, polyline };
    });
}
function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {
    var _a;
    if (!(0, store_1.hasTool)(tools_1.PlanarFreehandContourSegmentationTool)) {
        console.warn(`${tools_1.PlanarFreehandContourSegmentationTool.toolName} is not registered in cornerstone`);
        return;
    }
    if (!isFreehandContourSegToolRegisteredForViewport(viewport)) {
        return;
    }
    const sourceStartPoint = sourcePolyline[0];
    const mergePolylines = utilities_1.math.polyline.containsPoint(targetPolyline, sourceStartPoint);
    const contourHolesData = getContourHolesData(viewport, targetAnnotation);
    const unassignedContourHolesSet = new Set(contourHolesData);
    const reassignedContourHolesMap = new Map();
    const assignHoleToPolyline = (parentPolyline, holeData) => {
        let holes = reassignedContourHolesMap.get(parentPolyline);
        if (!holes) {
            holes = [];
            reassignedContourHolesMap.set(parentPolyline, holes);
        }
        holes.push(holeData);
        unassignedContourHolesSet.delete(holeData);
    };
    const newPolylines = [];
    if (mergePolylines) {
        const mergedPolyline = utilities_1.math.polyline.mergePolylines(targetPolyline, sourcePolyline);
        newPolylines.push(mergedPolyline);
        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));
    }
    else {
        const subtractedPolylines = utilities_1.math.polyline.subtractPolylines(targetPolyline, sourcePolyline);
        subtractedPolylines.forEach((newPolyline) => {
            newPolylines.push(newPolyline);
            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {
                const containsHole = utilities_1.math.polyline.containsPoints(newPolyline, holeData.polyline);
                if (containsHole) {
                    assignHoleToPolyline(newPolyline, holeData);
                    unassignedContourHolesSet.delete(holeData);
                }
            });
        });
    }
    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => (0, annotationState_1.clearParentAnnotation)(contourHoleData.annotation)));
    const { element } = viewport;
    const enabledElement = (0, core_1.getEnabledElement)(element);
    const { metadata, data } = targetAnnotation;
    const { handles, segmentation } = data;
    const { textBox } = handles;
    (0, annotationState_1.removeAnnotation)(sourceAnnotation.annotationUID);
    (0, annotationState_1.removeAnnotation)(targetAnnotation.annotationUID);
    for (let i = 0; i < newPolylines.length; i++) {
        const polyline = newPolylines[i];
        const startPoint = viewport.canvasToWorld(polyline[0]);
        const endPoint = viewport.canvasToWorld(polyline[polyline.length - 1]);
        const newAnnotation = {
            metadata: Object.assign(Object.assign({}, metadata), { toolName: DEFAULT_CONTOUR_SEG_TOOLNAME, originalToolName: metadata.originalToolName || metadata.toolName }),
            data: {
                cachedStats: {},
                handles: {
                    points: [startPoint, endPoint],
                    textBox: textBox ? Object.assign({}, textBox) : undefined,
                },
                contour: {
                    polyline: [],
                    closed: true,
                },
                spline: targetAnnotation.data.spline,
                segmentation: Object.assign({}, segmentation),
            },
            annotationUID: core_1.utilities.uuidv4(),
            highlighted: true,
            invalidated: true,
            isLocked: false,
            isVisible: undefined,
            interpolationUID: targetAnnotation.interpolationUID,
            interpolationCompleted: targetAnnotation.interpolationCompleted,
        };
        contourUtils.updateContourPolyline(newAnnotation, {
            points: polyline,
            closed: true,
            targetWindingDirection: ContourAnnotation_1.ContourWindingDirection.Clockwise,
        }, viewport);
        (0, annotationState_1.addAnnotation)(newAnnotation, element);
        contourSegUtils.addContourSegmentationAnnotation(newAnnotation);
        (0, state_1.triggerAnnotationModified)(newAnnotation, viewport.element);
        (_a = reassignedContourHolesMap
            .get(polyline)) === null || _a === void 0 ? void 0 : _a.forEach((holeData) => (0, annotationState_1.addChildAnnotation)(newAnnotation, holeData.annotation));
    }
    updateViewports(enabledElement, targetAnnotation, sourceAnnotation);
}
function updateViewports(enabledElement, targetAnnotation, sourceAnnotation) {
    const { viewport } = enabledElement;
    const { element } = viewport;
    const { renderingEngine } = enabledElement;
    const updatedTtoolNames = new Set([
        DEFAULT_CONTOUR_SEG_TOOLNAME,
        targetAnnotation.metadata.toolName,
        sourceAnnotation.metadata.toolName,
    ]);
    for (const toolName of updatedTtoolNames.values()) {
        const viewportIdsToRender = (0, viewportFilters_1.getViewportIdsWithToolToRender)(element, toolName);
        (0, utilities_1.triggerAnnotationRenderForViewportIds)(renderingEngine, viewportIdsToRender);
    }
    return new Promise((resolve) => window.requestAnimationFrame(resolve));
}
//# sourceMappingURL=contourSegmentationCompleted.js.map