"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updatePolyDataCache = exports.generateCacheId = exports.getSurfaceActorUID = exports.clipAndCacheSurfacesForViewport = void 0;
const core_1 = require("@cornerstonejs/core");
const enums_1 = require("../../../enums");
const utilities_1 = require("../../../utilities");
const registerPolySegWorker_1 = require("../polySeg/registerPolySegWorker");
const workerManager = (0, core_1.getWebWorkerManager)();
const polyDataCache = new Map();
const surfacesAABBCache = new Map();
const triggerWorkerProgress = (eventTarget, progress) => {
    (0, core_1.triggerEvent)(eventTarget, core_1.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: enums_1.WorkerTypes.SURFACE_CLIPPING,
    });
};
function clipAndCacheSurfacesForViewport(surfacesInfo, viewport, segmentationRepresentationUID) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        (0, registerPolySegWorker_1.registerPolySegWorker)();
        const planesInfo = (_a = viewport.getSlicesClippingPlanes) === null || _a === void 0 ? void 0 : _a.call(viewport);
        if (!planesInfo) {
            return;
        }
        const currentSliceIndex = viewport.getSliceIndex();
        planesInfo.sort((a, b) => {
            const diffA = Math.abs(a.sliceIndex - currentSliceIndex);
            const diffB = Math.abs(b.sliceIndex - currentSliceIndex);
            return diffA - diffB;
        });
        triggerWorkerProgress(core_1.eventTarget, 0);
        yield updateSurfacesAABBCache(surfacesInfo);
        const surfacesAABB = new Map();
        surfacesInfo.forEach((surface) => {
            surfacesAABB.set(surface.id, surfacesAABBCache.get(surface.id));
        });
        const camera = viewport.getCamera();
        yield workerManager
            .executeTask('polySeg', 'cutSurfacesIntoPlanes', {
            surfacesInfo,
            planesInfo,
            surfacesAABB,
        }, {
            callbacks: [
                ({ progress }) => {
                    triggerWorkerProgress(core_1.eventTarget, progress);
                },
                ({ sliceIndex, polyDataResults }) => {
                    polyDataResults.forEach((polyDataResult, surfaceId) => {
                        const actorUID = `${segmentationRepresentationUID}_${surfaceId}`;
                        const cacheId = generateCacheId(viewport, camera.viewPlaneNormal, sliceIndex);
                        updatePolyDataCache(actorUID, cacheId, polyDataResult);
                    });
                },
            ],
        })
            .catch((error) => {
            console.error(error);
        });
        triggerWorkerProgress(core_1.eventTarget, 1);
        return polyDataCache;
    });
}
exports.clipAndCacheSurfacesForViewport = clipAndCacheSurfacesForViewport;
function updateSurfacesAABBCache(surfacesInfo) {
    return __awaiter(this, void 0, void 0, function* () {
        const surfacesWithoutAABB = surfacesInfo.filter((surface) => !surfacesAABBCache.has(surface.id));
        if (!surfacesWithoutAABB.length) {
            return;
        }
        const surfacesAABB = yield workerManager.executeTask('polySeg', 'getSurfacesAABBs', {
            surfacesInfo: surfacesWithoutAABB,
        }, {
            callbacks: [
                ({ progress }) => {
                    triggerWorkerProgress(core_1.eventTarget, progress);
                },
            ],
        });
        surfacesAABB.forEach((aabb, id) => {
            surfacesAABBCache.set(id, aabb);
        });
    });
}
function getSurfaceActorUID(segmentationRepresentationUID, surfaceId) {
    return `${segmentationRepresentationUID}_${surfaceId}`;
}
exports.getSurfaceActorUID = getSurfaceActorUID;
function generateCacheId(viewport, viewPlaneNormal, sliceIndex) {
    return `${viewport.id}-${(0, utilities_1.pointToString)(viewPlaneNormal)}-${sliceIndex}`;
}
exports.generateCacheId = generateCacheId;
function updatePolyDataCache(actorUID, cacheId, polyDataResult) {
    const { points, lines, numberOfCells } = polyDataResult;
    let actorCache = polyDataCache.get(actorUID);
    if (!actorCache) {
        actorCache = new Map();
        polyDataCache.set(actorUID, actorCache);
    }
    actorCache.set(cacheId, { points, lines, numberOfCells });
}
exports.updatePolyDataCache = updatePolyDataCache;
//# sourceMappingURL=clipAndCacheSurfacesForViewport.js.map