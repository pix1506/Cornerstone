"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.canComputeRequestedRepresentation = void 0;
const enums_1 = require("../../../enums");
const Labelmap_1 = require("../../../tools/displayTools/Labelmap");
const segmentationState_1 = require("../segmentationState");
const conversionPaths = new Map([
    [
        enums_1.SegmentationRepresentations.Labelmap,
        new Set([
            enums_1.SegmentationRepresentations.Surface,
            enums_1.SegmentationRepresentations.Contour,
        ]),
    ],
    [
        enums_1.SegmentationRepresentations.Contour,
        new Set([
            enums_1.SegmentationRepresentations.Labelmap,
            enums_1.SegmentationRepresentations.Surface,
        ]),
    ],
    [
        enums_1.SegmentationRepresentations.Surface,
        new Set([enums_1.SegmentationRepresentations.Labelmap]),
    ],
]);
function canComputeRequestedRepresentation(segmentationRepresentationUID) {
    const representationInfo = (0, segmentationState_1.findSegmentationRepresentationByUID)(segmentationRepresentationUID);
    if (!(representationInfo === null || representationInfo === void 0 ? void 0 : representationInfo.segmentationRepresentation)) {
        return false;
    }
    const { segmentationRepresentation } = representationInfo;
    const { type: representationType, polySeg } = segmentationRepresentation;
    if (!polySeg || !polySeg.enabled) {
        return false;
    }
    const { representationData } = (0, segmentationState_1.getSegmentation)(segmentationRepresentation.segmentationId);
    const existingRepresentationTypes = getExistingRepresentationTypes(representationData);
    return existingRepresentationTypes.some((existingRepresentationType) => canConvertFromTo(existingRepresentationType, representationType));
}
exports.canComputeRequestedRepresentation = canComputeRequestedRepresentation;
function getExistingRepresentationTypes(representationData) {
    const supportedTypes = [];
    Object.keys(representationData).forEach((representationType) => {
        const representationTypeData = representationData[representationType];
        let validateFn;
        switch (representationType) {
            case enums_1.SegmentationRepresentations.Labelmap:
                validateFn = Labelmap_1.validateLabelmap;
                break;
        }
        if (validateFn) {
            try {
                validateFn(representationTypeData);
                supportedTypes.push(representationType);
            }
            catch (error) {
                console.warn(`Validation failed for labelmap of type ${representationType}`);
            }
        }
        else {
            supportedTypes.push(representationType);
        }
    });
    return supportedTypes;
}
function canConvertFromTo(fromRepresentationType, toRepresentationType) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        return (((_a = conversionPaths.get(fromRepresentationType)) === null || _a === void 0 ? void 0 : _a.has(toRepresentationType)) ||
            false);
    });
}
//# sourceMappingURL=canComputeRequestedRepresentation.js.map