"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertContourToStackLabelmap = exports.convertContourToVolumeLabelmap = void 0;
const gl_matrix_1 = require("gl-matrix");
const core_1 = require("@cornerstonejs/core");
const __1 = require("../../..");
const enums_1 = require("../../../../enums");
const workerManager = (0, core_1.getWebWorkerManager)();
const triggerWorkerProgress = (eventTarget, progress) => {
    (0, core_1.triggerEvent)(eventTarget, core_1.Enums.Events.WEB_WORKER_PROGRESS, {
        progress,
        type: enums_1.WorkerTypes.POLYSEG_CONTOUR_TO_LABELMAP,
    });
};
function convertContourToVolumeLabelmap(contourRepresentationData, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { viewport } = options;
        const imageIds = core_1.utilities.getViewportImageIds(viewport);
        if (!imageIds) {
            throw new Error('No imageIds found, labelmap computation from contour requires viewports with imageIds');
        }
        const segmentationVolumeId = core_1.utilities.uuidv4();
        const volumeProps = core_1.utilities.generateVolumePropsFromImageIds(imageIds, segmentationVolumeId);
        const { metadata, dimensions, origin, direction, spacing, scalarData } = volumeProps;
        const segmentationVolume = yield core_1.volumeLoader.createLocalSegmentationVolume({
            dimensions,
            origin,
            direction,
            spacing,
            metadata,
            imageIds: imageIds.map((imageId) => `generated://${imageId}`),
            referencedImageIds: imageIds,
        }, segmentationVolumeId);
        const { segmentIndices, annotationUIDsInSegmentMap } = _getAnnotationMapFromSegmentation(contourRepresentationData, options);
        triggerWorkerProgress(core_1.eventTarget, 0);
        const newScalarData = yield workerManager.executeTask('polySeg', 'convertContourToVolumeLabelmap', {
            segmentIndices,
            dimensions,
            scalarData,
            origin,
            direction,
            spacing,
            annotationUIDsInSegmentMap,
        }, {
            callbacks: [
                (progress) => {
                    triggerWorkerProgress(core_1.eventTarget, progress);
                },
            ],
        });
        triggerWorkerProgress(core_1.eventTarget, 1);
        segmentationVolume.imageData
            .getPointData()
            .getScalars()
            .setData(newScalarData);
        segmentationVolume.imageData.modified();
        segmentationVolume.modified();
        return {
            volumeId: segmentationVolume.volumeId,
        };
    });
}
exports.convertContourToVolumeLabelmap = convertContourToVolumeLabelmap;
function convertContourToStackLabelmap(contourRepresentationData, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.viewport) {
            throw new Error('No viewport provided, labelmap computation from contour requires viewports');
        }
        const viewport = options.viewport;
        const imageIds = viewport.getImageIds();
        if (!imageIds) {
            throw new Error('No imageIds found, labelmap computation from contour requires viewports with imageIds');
        }
        imageIds.forEach((imageId) => {
            if (!core_1.cache.getImageLoadObject(imageId)) {
                throw new Error('ImageIds must be cached before converting contour to labelmap');
            }
        });
        const { imageIds: segmentationImageIds } = yield core_1.imageLoader.createAndCacheDerivedSegmentationImages(imageIds);
        const { segmentIndices, annotationUIDsInSegmentMap } = _getAnnotationMapFromSegmentation(contourRepresentationData, options);
        const segmentationsInfo = new Map();
        segmentationImageIds.forEach((segImageId, index) => {
            const segImage = core_1.cache.getImage(segImageId);
            const imagePlaneModule = core_1.metaData.get(core_1.Enums.MetadataModules.IMAGE_PLANE, segImageId);
            let { columnCosines, rowCosines, rowPixelSpacing, columnPixelSpacing, imagePositionPatient, } = imagePlaneModule;
            columnCosines = columnCosines !== null && columnCosines !== void 0 ? columnCosines : [0, 1, 0];
            rowCosines = rowCosines !== null && rowCosines !== void 0 ? rowCosines : [1, 0, 0];
            rowPixelSpacing = rowPixelSpacing !== null && rowPixelSpacing !== void 0 ? rowPixelSpacing : 1;
            columnPixelSpacing = columnPixelSpacing !== null && columnPixelSpacing !== void 0 ? columnPixelSpacing : 1;
            imagePositionPatient = imagePositionPatient !== null && imagePositionPatient !== void 0 ? imagePositionPatient : [0, 0, 0];
            const rowCosineVec = gl_matrix_1.vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);
            const colCosineVec = gl_matrix_1.vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);
            const scanAxisNormal = gl_matrix_1.vec3.create();
            gl_matrix_1.vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);
            const direction = [...rowCosineVec, ...colCosineVec, ...scanAxisNormal];
            const spacing = [rowPixelSpacing, columnPixelSpacing, 1];
            const origin = imagePositionPatient;
            segmentationsInfo.set(imageIds[index], {
                direction,
                spacing,
                origin,
                scalarData: segImage.getPixelData(),
                imageId: segImageId,
                dimensions: [segImage.width, segImage.height, 1],
            });
        });
        triggerWorkerProgress(core_1.eventTarget, 0);
        const newSegmentationsScalarData = yield workerManager.executeTask('polySeg', 'convertContourToStackLabelmap', {
            segmentationsInfo,
            annotationUIDsInSegmentMap,
            segmentIndices,
        }, {
            callbacks: [
                (progress) => {
                    triggerWorkerProgress(core_1.eventTarget, progress);
                },
            ],
        });
        triggerWorkerProgress(core_1.eventTarget, 1);
        const imageIdReferenceMap = new Map();
        newSegmentationsScalarData.forEach(({ scalarData }, referencedImageId) => {
            var _a, _b;
            const segmentationInfo = segmentationsInfo.get(referencedImageId);
            const { imageId: segImageId } = segmentationInfo;
            const segImage = core_1.cache.getImage(segImageId);
            segImage.getPixelData().set(scalarData);
            (_b = (_a = segImage.imageFrame) === null || _a === void 0 ? void 0 : _a.pixelData) === null || _b === void 0 ? void 0 : _b.set(scalarData);
            imageIdReferenceMap.set(referencedImageId, segImageId);
        });
        return {
            imageIdReferenceMap,
        };
    });
}
exports.convertContourToStackLabelmap = convertContourToStackLabelmap;
function _getAnnotationMapFromSegmentation(contourRepresentationData, options = {}) {
    var _a;
    const annotationMap = contourRepresentationData.annotationUIDsMap;
    const segmentIndices = ((_a = options.segmentIndices) === null || _a === void 0 ? void 0 : _a.length)
        ? options.segmentIndices
        : Array.from(annotationMap.keys());
    const annotationUIDsInSegmentMap = new Map();
    segmentIndices.forEach((index) => {
        const annotationUIDsInSegment = annotationMap.get(index);
        let uids = Array.from(annotationUIDsInSegment);
        uids = uids.filter((uid) => !(0, __1.getAnnotation)(uid).parentAnnotationUID);
        const annotations = uids.map((uid) => {
            var _a;
            const annotation = (0, __1.getAnnotation)(uid);
            const hasChildAnnotations = (_a = annotation.childAnnotationUIDs) === null || _a === void 0 ? void 0 : _a.length;
            return {
                polyline: annotation.data.contour.polyline,
                referencedImageId: annotation.metadata.referencedImageId,
                holesPolyline: hasChildAnnotations &&
                    annotation.childAnnotationUIDs.map((childUID) => {
                        const childAnnotation = (0, __1.getAnnotation)(childUID);
                        return childAnnotation.data.contour.polyline;
                    }),
            };
        });
        annotationUIDsInSegmentMap.set(index, annotations);
    });
    return { segmentIndices, annotationUIDsInSegmentMap };
}
//# sourceMappingURL=convertContourToLabelmap.js.map