"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateContoursOnCameraModified = void 0;
const core_1 = require("@cornerstonejs/core");
const extractContourData_1 = require("./extractContourData");
const clipAndCacheSurfacesForViewport_1 = require("../../../helpers/clipAndCacheSurfacesForViewport");
const createAndAddContourSegmentationsFromClippedSurfaces_1 = require("./createAndAddContourSegmentationsFromClippedSurfaces");
const currentViewportNormal = new Map();
function updateContoursOnCameraModified(surfacesInfo, viewport, segmentationRepresentationUID) {
    function cameraModifiedCallback(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { camera } = evt.detail;
            const { viewPlaneNormal } = camera;
            const surface1 = surfacesInfo[0];
            const currentNormal = currentViewportNormal.get(surface1.id);
            if (core_1.utilities.isEqual(viewPlaneNormal, currentNormal)) {
                return;
            }
            currentViewportNormal.set(surface1.id, viewPlaneNormal);
            const polyDataCache = yield (0, clipAndCacheSurfacesForViewport_1.clipAndCacheSurfacesForViewport)(surfacesInfo, viewport, segmentationRepresentationUID);
            const results = (0, extractContourData_1.extractContourData)(polyDataCache);
            (0, createAndAddContourSegmentationsFromClippedSurfaces_1.createAndAddContourSegmentationsFromClippedSurfaces)(results, viewport, segmentationRepresentationUID);
            viewport.render();
        });
    }
    const camera = viewport.getCamera();
    currentViewportNormal.set(surfacesInfo[0].id, camera.viewPlaneNormal);
    viewport.element.removeEventListener(core_1.Enums.Events.CAMERA_MODIFIED, cameraModifiedCallback);
    viewport.element.addEventListener(core_1.Enums.Events.CAMERA_MODIFIED);
}
exports.updateContoursOnCameraModified = updateContoursOnCameraModified;
//# sourceMappingURL=updateContoursOnCameraModified.js.map