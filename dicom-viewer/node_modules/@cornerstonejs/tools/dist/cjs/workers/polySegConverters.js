"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const comlink_1 = require("comlink");
const ImageData_1 = __importDefault(require("@kitware/vtk.js/Common/DataModel/ImageData"));
const DataArray_1 = __importDefault(require("@kitware/vtk.js/Common/Core/DataArray"));
const polyseg_wasm_1 = __importDefault(require("@icr/polyseg-wasm"));
const core_1 = require("@cornerstonejs/core");
const Plane_1 = __importDefault(require("@kitware/vtk.js/Common/DataModel/Plane"));
const PolyData_1 = __importDefault(require("@kitware/vtk.js/Common/DataModel/PolyData"));
const ContourLoopExtraction_1 = __importDefault(require("@kitware/vtk.js/Filters/General/ContourLoopExtraction"));
const Cutter_1 = __importDefault(require("@kitware/vtk.js/Filters/Core/Cutter"));
const boundingBox_1 = require("../utilities/boundingBox");
const utilities_1 = require("../utilities");
const polyline_1 = require("../utilities/math/polyline");
const planar_1 = require("../utilities/planar");
const polySegConverters = {
    polySeg: null,
    polySegInitializing: false,
    polySegInitializingPromise: null,
    initializePolySeg(progressCallback) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.polySegInitializing) {
                yield this.polySegInitializingPromise;
                return;
            }
            if ((_a = this.polySeg) === null || _a === void 0 ? void 0 : _a.instance) {
                return;
            }
            this.polySegInitializing = true;
            this.polySegInitializingPromise = new Promise((resolve) => {
                this.polySeg = new polyseg_wasm_1.default();
                this.polySeg
                    .initialize({
                    updateProgress: progressCallback,
                })
                    .then(() => {
                    this.polySegInitializing = false;
                    resolve();
                });
            });
            yield this.polySegInitializingPromise;
        });
    },
    convertContourToSurface(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const { polylines, numPointsArray } = args;
            const [progressCallback] = callbacks;
            yield this.initializePolySeg(progressCallback);
            const results = yield this.polySeg.instance.convertContourRoiToSurface(polylines, numPointsArray);
            return results;
        });
    },
    convertLabelmapToSurface(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const [progressCallback] = callbacks;
            yield this.initializePolySeg(progressCallback);
            const results = this.polySeg.instance.convertLabelmapToSurface(args.scalarData, args.dimensions, args.spacing, args.direction, args.origin, [args.segmentIndex]);
            return results;
        });
    },
    convertContourToVolumeLabelmap(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const [progressCallback] = callbacks;
            const polySeg = yield new polyseg_wasm_1.default();
            yield polySeg.initialize({
                updateProgress: progressCallback,
            });
            const { segmentIndices, scalarData, annotationUIDsInSegmentMap, dimensions, origin, direction, spacing, } = args;
            const segmentationVoxelManager = core_1.utilities.VoxelManager.createVolumeVoxelManager(dimensions, scalarData);
            const imageData = ImageData_1.default.newInstance();
            imageData.setDimensions(dimensions);
            imageData.setOrigin(origin);
            imageData.setDirection(direction);
            imageData.setSpacing(spacing);
            const scalarArray = DataArray_1.default.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: scalarData,
            });
            imageData.getPointData().setScalars(scalarArray);
            imageData.modified();
            for (const index of segmentIndices) {
                const annotations = annotationUIDsInSegmentMap.get(index);
                for (const annotation of annotations) {
                    if (!annotation.polyline) {
                        continue;
                    }
                    const { polyline, holesPolyline } = annotation;
                    const bounds = (0, boundingBox_1.getBoundingBoxAroundShapeWorld)(polyline);
                    const [iMin, jMin, kMin] = core_1.utilities.transformWorldToIndex(imageData, [
                        bounds[0][0],
                        bounds[1][0],
                        bounds[2][0],
                    ]);
                    const [iMax, jMax, kMax] = core_1.utilities.transformWorldToIndex(imageData, [
                        bounds[0][1],
                        bounds[1][1],
                        bounds[2][1],
                    ]);
                    const { projectedPolyline, sharedDimensionIndex } = (0, polyline_1.projectTo2D)(polyline);
                    const holes = holesPolyline === null || holesPolyline === void 0 ? void 0 : holesPolyline.map((hole) => {
                        const { projectedPolyline: projectedHole } = (0, polyline_1.projectTo2D)(hole);
                        return projectedHole;
                    });
                    const firstDim = (sharedDimensionIndex + 1) % 3;
                    const secondDim = (sharedDimensionIndex + 2) % 3;
                    (0, utilities_1.pointInShapeCallback)(imageData, (pointLPS) => {
                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];
                        const isInside = (0, polyline_1.containsPoint)(projectedPolyline, point2D, {
                            holes,
                        });
                        return isInside;
                    }, ({ pointIJK }) => {
                        segmentationVoxelManager.setAtIJKPoint(pointIJK, index);
                    }, [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ]);
                }
            }
            return segmentationVoxelManager.scalarData;
        });
    },
    convertContourToStackLabelmap(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const [progressCallback] = callbacks;
            const polySeg = yield new polyseg_wasm_1.default();
            yield polySeg.initialize({
                updateProgress: progressCallback,
            });
            const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } = args;
            const segmentationVoxelManagers = new Map();
            segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {
                const { dimensions, scalarData, direction, spacing, origin } = segmentationInfo;
                const manager = core_1.utilities.VoxelManager.createVolumeVoxelManager(dimensions, scalarData);
                const imageData = ImageData_1.default.newInstance();
                imageData.setDimensions(dimensions);
                imageData.setOrigin(origin);
                imageData.setDirection(direction);
                imageData.setSpacing(spacing);
                const scalarArray = DataArray_1.default.newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: scalarData,
                });
                imageData.getPointData().setScalars(scalarArray);
                imageData.modified();
                segmentationVoxelManagers.set(referencedImageId, { manager, imageData });
            });
            for (const index of segmentIndices) {
                const annotations = annotationUIDsInSegmentMap.get(index);
                for (const annotation of annotations) {
                    if (!annotation.polyline) {
                        continue;
                    }
                    const { polyline, holesPolyline, referencedImageId } = annotation;
                    const bounds = (0, boundingBox_1.getBoundingBoxAroundShapeWorld)(polyline);
                    const { manager: segmentationVoxelManager, imageData } = segmentationVoxelManagers.get(referencedImageId);
                    const [iMin, jMin, kMin] = core_1.utilities.transformWorldToIndex(imageData, [
                        bounds[0][0],
                        bounds[1][0],
                        bounds[2][0],
                    ]);
                    const [iMax, jMax, kMax] = core_1.utilities.transformWorldToIndex(imageData, [
                        bounds[0][1],
                        bounds[1][1],
                        bounds[2][1],
                    ]);
                    const { projectedPolyline, sharedDimensionIndex } = (0, polyline_1.projectTo2D)(polyline);
                    const holes = holesPolyline === null || holesPolyline === void 0 ? void 0 : holesPolyline.map((hole) => {
                        const { projectedPolyline: projectedHole } = (0, polyline_1.projectTo2D)(hole);
                        return projectedHole;
                    });
                    const firstDim = (sharedDimensionIndex + 1) % 3;
                    const secondDim = (sharedDimensionIndex + 2) % 3;
                    (0, utilities_1.pointInShapeCallback)(imageData, (pointLPS) => {
                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];
                        const isInside = (0, polyline_1.containsPoint)(projectedPolyline, point2D, {
                            holes,
                        });
                        return isInside;
                    }, ({ pointIJK }) => {
                        segmentationVoxelManager.setAtIJKPoint(pointIJK, index);
                    }, [
                        [iMin, iMax],
                        [jMin, jMax],
                        [kMin, kMax],
                    ]);
                }
            }
            segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {
                const { manager: segmentationVoxelManager } = segmentationVoxelManagers.get(referencedImageId);
                segmentationInfo.scalarData = segmentationVoxelManager.scalarData;
            });
            return segmentationsInfo;
        });
    },
    convertSurfaceToVolumeLabelmap(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const [progressCallback] = callbacks;
            yield this.initializePolySeg(progressCallback);
            const results = this.polySeg.instance.convertSurfaceToLabelmap(args.points, args.polys, args.dimensions, args.spacing, args.direction, args.origin);
            return results;
        });
    },
    convertSurfacesToVolumeLabelmap(args, ...callbacks) {
        return __awaiter(this, void 0, void 0, function* () {
            const [progressCallback] = callbacks;
            yield this.initializePolySeg(progressCallback);
            const { segmentsInfo } = args;
            const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {
                const { points, polys } = segmentsInfo.get(segmentIndex);
                const result = this.polySeg.instance.convertSurfaceToLabelmap(points, polys, args.dimensions, args.spacing, args.direction, args.origin);
                return Object.assign(Object.assign({}, result), { segmentIndex });
            });
            const results = yield Promise.all(promises);
            const targetImageData = ImageData_1.default.newInstance();
            targetImageData.setDimensions(args.dimensions);
            targetImageData.setOrigin(args.origin);
            targetImageData.setSpacing(args.spacing);
            targetImageData.setDirection(args.direction);
            const totalSize = args.dimensions[0] * args.dimensions[1] * args.dimensions[2];
            const scalarArray = DataArray_1.default.newInstance({
                name: 'Pixels',
                numberOfComponents: 1,
                values: new Uint8Array(totalSize),
            });
            targetImageData.getPointData().setScalars(scalarArray);
            targetImageData.modified();
            const segmentationVoxelManager = core_1.utilities.VoxelManager.createVolumeVoxelManager(args.dimensions, targetImageData.getPointData().getScalars().getData());
            const outputVolumesInfo = results.map((result) => {
                const { data, dimensions, direction, origin, spacing } = result;
                const volume = ImageData_1.default.newInstance();
                volume.setDimensions(dimensions);
                volume.setOrigin(origin);
                volume.setSpacing(spacing);
                volume.setDirection(direction);
                const scalarArray = DataArray_1.default.newInstance({
                    name: 'Pixels',
                    numberOfComponents: 1,
                    values: data,
                });
                volume.getPointData().setScalars(scalarArray);
                volume.modified();
                const voxelManager = core_1.utilities.VoxelManager.createVolumeVoxelManager(dimensions, data);
                const extent = volume.getExtent();
                return {
                    volume,
                    voxelManager,
                    extent,
                    scalarData: data,
                    segmentIndex: result.segmentIndex,
                };
            });
            (0, utilities_1.pointInShapeCallback)(targetImageData, () => true, ({ pointIJK, pointLPS }) => {
                try {
                    for (const volumeInfo of outputVolumesInfo) {
                        const { volume, extent, voxelManager, segmentIndex } = volumeInfo;
                        const index = volume.worldToIndex(pointLPS);
                        if (index[0] < extent[0] ||
                            index[0] > extent[1] ||
                            index[1] < extent[2] ||
                            index[1] > extent[3] ||
                            index[2] < extent[4] ||
                            index[2] > extent[5]) {
                            continue;
                        }
                        const roundedIndex = index.map(Math.round);
                        const value = voxelManager.getAtIJK(...roundedIndex);
                        if (value > 0) {
                            segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);
                            break;
                        }
                    }
                }
                catch (error) {
                }
            });
            return segmentationVoxelManager.scalarData;
        });
    },
    getSurfacesAABBs({ surfacesInfo }) {
        const aabbs = new Map();
        for (const { points, id } of surfacesInfo) {
            const aabb = (0, polyline_1.getAABB)(points, { numDimensions: 3 });
            aabbs.set(id, aabb);
        }
        return aabbs;
    },
    cutSurfacesIntoPlanes({ planesInfo, surfacesInfo, surfacesAABB = new Map() }, progressCallback, updateCacheCallback) {
        const numberOfPlanes = planesInfo.length;
        const cutter = Cutter_1.default.newInstance();
        const plane1 = Plane_1.default.newInstance();
        cutter.setCutFunction(plane1);
        const surfacePolyData = PolyData_1.default.newInstance();
        try {
            for (const [index, planeInfo] of planesInfo.entries()) {
                const { sliceIndex, planes } = planeInfo;
                const polyDataResults = new Map();
                for (const polyDataInfo of surfacesInfo) {
                    const { points, polys, id } = polyDataInfo;
                    const aabb3 = surfacesAABB.get(id) || (0, polyline_1.getAABB)(points, { numDimensions: 3 });
                    if (!surfacesAABB.has(id)) {
                        surfacesAABB.set(id, aabb3);
                    }
                    const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;
                    const { origin, normal } = planes[0];
                    if (!(0, planar_1.isPlaneIntersectingAABB)(origin, normal, minX, minY, minZ, maxX, maxY, maxZ)) {
                        continue;
                    }
                    surfacePolyData.getPoints().setData(points, 3);
                    surfacePolyData.getPolys().setData(polys, 3);
                    surfacePolyData.modified();
                    cutter.setInputData(surfacePolyData);
                    plane1.setOrigin(origin);
                    plane1.setNormal(normal);
                    try {
                        cutter.update();
                    }
                    catch (e) {
                        console.warn('Error during clipping', e);
                        continue;
                    }
                    const polyData = cutter.getOutputData();
                    const cutterOutput = polyData;
                    cutterOutput.buildLinks();
                    const loopExtraction = ContourLoopExtraction_1.default.newInstance();
                    loopExtraction.setInputData(cutterOutput);
                    const loopOutput = loopExtraction.getOutputData();
                    if (polyData) {
                        polyDataResults.set(id, {
                            points: loopOutput.getPoints().getData(),
                            lines: loopOutput.getLines().getData(),
                            numberOfCells: loopOutput.getLines().getNumberOfCells(),
                        });
                    }
                }
                progressCallback({ progress: (index + 1) / numberOfPlanes });
                updateCacheCallback({ sliceIndex, polyDataResults });
            }
        }
        catch (e) {
            console.warn('Error during processing', e);
        }
        finally {
            surfacesInfo = null;
            plane1.delete();
        }
    },
};
(0, comlink_1.expose)(polySegConverters);
//# sourceMappingURL=polySegConverters.js.map