"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const annotationState_1 = require("../../../stateManagement/annotation/annotationState");
const DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';
function getInterpolationData(viewportData, filterParams = []) {
    const { viewport, sliceData, annotation } = viewportData;
    const interpolationDatas = new Map();
    const { toolName, originalToolName } = annotation.metadata;
    const testToolName = originalToolName || toolName;
    const annotations = ((0, annotationState_1.getAnnotations)(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||
        annotation.metadata.originalToolName === testToolName);
    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {
        const modifiedAnnotations = (0, annotationState_1.getAnnotations)(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);
        if (modifiedAnnotations === null || modifiedAnnotations === void 0 ? void 0 : modifiedAnnotations.length) {
            modifiedAnnotations.forEach((annotation) => {
                const { metadata } = annotation;
                if (metadata.originalToolName === testToolName &&
                    metadata.originalToolName !== metadata.toolName) {
                    annotations.push(annotation);
                }
            });
        }
    }
    if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
        return interpolationDatas;
    }
    for (let i = 0; i < sliceData.numberOfSlices; i++) {
        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);
        if (!(imageAnnotations === null || imageAnnotations === void 0 ? void 0 : imageAnnotations.length)) {
            continue;
        }
        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {
            return filterParams.every((x) => {
                const parent = x.parentKey
                    ? x.parentKey(imageAnnotation)
                    : imageAnnotation;
                const value = parent === null || parent === void 0 ? void 0 : parent[x.key];
                if (Array.isArray(value)) {
                    return value.every((item, index) => item === x.value[index]);
                }
                return value === x.value;
            });
        });
        if (filteredInterpolatedAnnotations.length) {
            interpolationDatas.set(i, filteredInterpolatedAnnotations);
        }
    }
    return interpolationDatas;
}
exports.default = getInterpolationData;
//# sourceMappingURL=getInterpolationData.js.map