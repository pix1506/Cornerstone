"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@cornerstonejs/core");
const annotation_1 = require("../../../stateManagement/annotation");
const getInterpolationDataCollection_1 = __importDefault(require("../../contours/interpolation/getInterpolationDataCollection"));
const interpolate_1 = __importDefault(require("../../contours/interpolation/interpolate"));
const deleteRelatedAnnotations_1 = __importDefault(require("./deleteRelatedAnnotations"));
const ChangeTypes_1 = __importDefault(require("../../../enums/ChangeTypes"));
const getViewportForAnnotation_1 = __importDefault(require("../../getViewportForAnnotation"));
const addContourSegmentationAnnotation_1 = require("../../contourSegmentation/addContourSegmentationAnnotation");
const { uuidv4 } = core_1.utilities;
const ChangeTypesForInterpolation = [
    ChangeTypes_1.default.HandlesUpdated,
    ChangeTypes_1.default.InterpolationUpdated,
];
class InterpolationManager {
    static addTool(toolName) {
        if (!this.toolNames.includes(toolName)) {
            this.toolNames.push(toolName);
        }
    }
    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {
        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;
        for (const toolName of toolNames || InterpolationManager.toolNames) {
            const annotations = annotation_1.state.getAnnotations(toolName, annotationGroupSelector);
            if (!(annotations === null || annotations === void 0 ? void 0 : annotations.length)) {
                continue;
            }
            for (const annotation of annotations) {
                const { interpolationUID, data, autoGenerated, metadata } = annotation;
                if (interpolationUID) {
                    annotation.interpolationCompleted = true;
                }
                if (!autoGenerated) {
                    continue;
                }
                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {
                    continue;
                }
                if (sliceIndex !== undefined &&
                    metadata &&
                    sliceIndex !== metadata.sliceIndex) {
                    continue;
                }
                if (segmentationId &&
                    segmentationId !== data.segmentation.segmentationId) {
                    continue;
                }
                (0, addContourSegmentationAnnotation_1.addContourSegmentationAnnotation)(annotation);
                annotation.autoGenerated = false;
            }
        }
    }
}
exports.default = InterpolationManager;
_a = InterpolationManager;
InterpolationManager.toolNames = [];
InterpolationManager.handleAnnotationCompleted = (evt) => {
    var _b;
    const annotation = evt.detail.annotation;
    if (!(annotation === null || annotation === void 0 ? void 0 : annotation.metadata)) {
        return;
    }
    const { toolName, originalToolName } = annotation.metadata;
    if (!_a.toolNames.includes(toolName) &&
        !_a.toolNames.includes(originalToolName)) {
        return;
    }
    const viewport = (0, getViewportForAnnotation_1.default)(annotation);
    if (!viewport) {
        console.warn('Unable to find viewport for', annotation);
        return;
    }
    const sliceData = getSliceData(viewport);
    const viewportData = {
        viewport,
        sliceData,
        annotation,
        interpolationUID: annotation.interpolationUID,
    };
    const hasInterpolationUID = !!annotation.interpolationUID;
    annotation.autoGenerated = false;
    if (hasInterpolationUID) {
        (0, deleteRelatedAnnotations_1.default)(viewportData);
        (0, interpolate_1.default)(viewportData);
        return;
    }
    const filterData = [
        {
            key: 'segmentIndex',
            value: annotation.data.segmentation.segmentIndex,
            parentKey: (annotation) => annotation.data.segmentation,
        },
        {
            key: 'viewPlaneNormal',
            value: annotation.metadata.viewPlaneNormal,
            parentKey: (annotation) => annotation.metadata,
        },
        {
            key: 'viewUp',
            value: annotation.metadata.viewUp,
            parentKey: (annotation) => annotation.metadata,
        },
    ];
    let interpolationAnnotations = (0, getInterpolationDataCollection_1.default)(viewportData, filterData);
    const { sliceIndex } = annotation.metadata;
    const skipUIDs = new Set();
    interpolationAnnotations.forEach((interpolationAnnotation) => {
        if (interpolationAnnotation.interpolationCompleted ||
            interpolationAnnotation.metadata.sliceIndex === sliceIndex) {
            const { interpolationUID } = interpolationAnnotation;
            skipUIDs.add(interpolationUID);
        }
    });
    interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));
    annotation.interpolationUID =
        ((_b = interpolationAnnotations[0]) === null || _b === void 0 ? void 0 : _b.interpolationUID) || uuidv4();
    viewportData.interpolationUID = annotation.interpolationUID;
    (0, interpolate_1.default)(viewportData);
};
InterpolationManager.handleAnnotationUpdate = (evt) => {
    const annotation = evt.detail.annotation;
    const { changeType = ChangeTypes_1.default.HandlesUpdated } = evt.detail;
    if (!(annotation === null || annotation === void 0 ? void 0 : annotation.metadata)) {
        return;
    }
    const { toolName, originalToolName } = annotation.metadata;
    if ((!_a.toolNames.includes(toolName) &&
        !_a.toolNames.includes(originalToolName)) ||
        !ChangeTypesForInterpolation.includes(changeType)) {
        return;
    }
    const viewport = (0, getViewportForAnnotation_1.default)(annotation);
    if (!viewport) {
        console.warn('Unable to find matching viewport for annotation interpolation', annotation);
        return;
    }
    if (annotation.autoGenerated) {
        (0, addContourSegmentationAnnotation_1.addContourSegmentationAnnotation)(annotation);
        annotation.autoGenerated = false;
    }
    const sliceData = getSliceData(viewport);
    const viewportData = {
        viewport,
        sliceData,
        annotation,
        interpolationUID: annotation.interpolationUID,
        isInterpolationUpdate: changeType === ChangeTypes_1.default.InterpolationUpdated,
    };
    (0, interpolate_1.default)(viewportData);
};
InterpolationManager.handleAnnotationDelete = (evt) => {
    const annotation = evt.detail.annotation;
    if (!(annotation === null || annotation === void 0 ? void 0 : annotation.metadata)) {
        return;
    }
    const { toolName } = annotation.metadata;
    if (!_a.toolNames.includes(toolName) || annotation.autoGenerated) {
        return;
    }
    const viewport = (0, getViewportForAnnotation_1.default)(annotation);
    if (!viewport) {
        console.warn("No viewport, can't delete interpolated results", annotation);
        return;
    }
    const sliceData = getSliceData(viewport);
    const viewportData = {
        viewport,
        sliceData,
        annotation,
        interpolationUID: annotation.interpolationUID,
    };
    annotation.autoGenerated = false;
    (0, deleteRelatedAnnotations_1.default)(viewportData);
};
function getSliceData(viewport) {
    const sliceData = {
        numberOfSlices: viewport.getNumberOfSlices(),
        imageIndex: viewport.getCurrentImageIdIndex(),
    };
    return sliceData;
}
//# sourceMappingURL=InterpolationManager.js.map