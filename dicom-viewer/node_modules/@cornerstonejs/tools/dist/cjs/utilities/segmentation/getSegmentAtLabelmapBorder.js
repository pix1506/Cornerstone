"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSegmentAtLabelmapBorder = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentationState_1 = require("../../stateManagement/segmentation/segmentationState");
const stackVolumeCheck_1 = require("../../tools/segmentation/strategies/utils/stackVolumeCheck");
function getSegmentAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {
    const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
    const labelmapData = segmentation.representationData.LABELMAP;
    if ((0, stackVolumeCheck_1.isVolumeSegmentation)(labelmapData)) {
        const { volumeId } = labelmapData;
        const segmentationVolume = core_1.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const imageData = segmentationVolume.imageData;
        const segmentIndex = imageData.getScalarValueFromWorld(worldPoint);
        const canvasPoint = viewport.worldToCanvas(worldPoint);
        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);
        return onEdge ? segmentIndex : undefined;
    }
    const { imageIdReferenceMap } = labelmapData;
    const currentImageId = viewport.getCurrentImageId();
    const segmentationImageId = imageIdReferenceMap.get(currentImageId);
    const image = core_1.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationRepresentations = (0, segmentationState_1.getSegmentationIdRepresentations)(segmentation.segmentationId);
    const { segmentationRepresentationUID } = segmentationRepresentations[0];
    const segmentationActor = viewport.getActor(segmentationRepresentationUID);
    const imageData = segmentationActor === null || segmentationActor === void 0 ? void 0 : segmentationActor.actor.getMapper().getInputData();
    const indexIJK = core_1.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        core_1.utilities.VoxelManager.createVolumeVoxelManager(dimensions, imageData.getPointData().getScalars().getData()));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);
    return onEdge ? segmentIndex : undefined;
}
exports.getSegmentAtLabelmapBorder = getSegmentAtLabelmapBorder;
function isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {
    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);
    for (const deltaI of neighborRange) {
        for (const deltaJ of neighborRange) {
            for (const deltaK of neighborRange) {
                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {
                    continue;
                }
                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);
                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {
                    return true;
                }
            }
        }
    }
    return false;
}
function isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {
        const neighborIJK = [
            indexIJK[0] + deltaI,
            indexIJK[1] + deltaJ,
            indexIJK[2] + deltaK,
        ];
        return voxelManager.getAtIJK(...neighborIJK);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
function isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {
    const getNeighborIndex = (deltaI, deltaJ) => {
        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];
        const worldPoint = viewport.canvasToWorld(neighborCanvas);
        return imageData.getScalarValueFromWorld(worldPoint);
    };
    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);
}
//# sourceMappingURL=getSegmentAtLabelmapBorder.js.map