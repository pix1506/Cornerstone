"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSegmentAtWorldForContour = exports.getSegmentAtWorldForLabelmap = exports.getSegmentAtWorldPoint = void 0;
const core_1 = require("@cornerstonejs/core");
const enums_1 = require("../../enums");
const segmentationState_1 = require("../../stateManagement/segmentation/segmentationState");
const stackVolumeCheck_1 = require("../../tools/segmentation/strategies/utils/stackVolumeCheck");
const stateManagement_1 = require("../../stateManagement");
const polyline_1 = require("../math/polyline");
function getSegmentAtWorldPoint(segmentationId, worldPoint, options = {}) {
    var _a;
    const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
    const representationData = segmentation.representationData;
    const desiredRepresentation = (_a = options === null || options === void 0 ? void 0 : options.representationType) !== null && _a !== void 0 ? _a : Object.keys(representationData)[0];
    if (!desiredRepresentation) {
        throw new Error(`Segmentation ${segmentationId} does not have any representations`);
    }
    switch (desiredRepresentation) {
        case enums_1.SegmentationRepresentations.Labelmap:
            return getSegmentAtWorldForLabelmap(segmentation, worldPoint, options);
        case enums_1.SegmentationRepresentations.Contour:
            return getSegmentAtWorldForContour(segmentation, worldPoint, options);
        default:
            return;
    }
}
exports.getSegmentAtWorldPoint = getSegmentAtWorldPoint;
function getSegmentAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {
    const labelmapData = segmentation.representationData.LABELMAP;
    if ((0, stackVolumeCheck_1.isVolumeSegmentation)(labelmapData)) {
        const { volumeId } = labelmapData;
        const segmentationVolume = core_1.cache.getVolume(volumeId);
        if (!segmentationVolume) {
            return;
        }
        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);
        return segmentIndex;
    }
    const { imageIdReferenceMap } = labelmapData;
    const currentImageId = viewport.getCurrentImageId();
    const segmentationImageId = imageIdReferenceMap.get(currentImageId);
    const image = core_1.cache.getImage(segmentationImageId);
    if (!image) {
        return;
    }
    const segmentationRepresentations = (0, segmentationState_1.getSegmentationIdRepresentations)(segmentation.segmentationId);
    const { segmentationRepresentationUID } = segmentationRepresentations[0];
    const segmentationActor = viewport.getActor(segmentationRepresentationUID);
    const imageData = segmentationActor === null || segmentationActor === void 0 ? void 0 : segmentationActor.actor.getMapper().getInputData();
    const indexIJK = core_1.utilities.transformWorldToIndex(imageData, worldPoint);
    const dimensions = imageData.getDimensions();
    const voxelManager = (imageData.voxelManager ||
        core_1.utilities.VoxelManager.createVolumeVoxelManager(dimensions, imageData.getPointData().getScalars().getData()));
    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);
    return segmentIndex;
}
exports.getSegmentAtWorldForLabelmap = getSegmentAtWorldForLabelmap;
function getSegmentAtWorldForContour(segmentation, worldPoint, { viewport }) {
    const contourData = segmentation.representationData.CONTOUR;
    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());
    const { viewPlaneNormal } = viewport.getCamera();
    for (const segmentIndex of segmentIndices) {
        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);
        if (!annotationsSet) {
            continue;
        }
        for (const annotationUID of annotationsSet) {
            const annotation = (0, stateManagement_1.getAnnotation)(annotationUID);
            if (!annotation) {
                continue;
            }
            const { polyline } = annotation.data.contour;
            if (!core_1.utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {
                continue;
            }
            if ((0, polyline_1.isPointInsidePolyline3D)(worldPoint, polyline)) {
                return Number(segmentIndex);
            }
        }
    }
}
exports.getSegmentAtWorldForContour = getSegmentAtWorldForContour;
//# sourceMappingURL=getSegmentAtWorldPoint.js.map