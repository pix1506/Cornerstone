"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueSegmentIndices = exports.setSegmentationClean = exports.setSegmentationDirty = void 0;
const core_1 = require("@cornerstonejs/core");
const segmentationState_1 = require("../../stateManagement/segmentation/segmentationState");
const stackVolumeCheck_1 = require("../../tools/segmentation/strategies/utils/stackVolumeCheck");
const enums_1 = require("../../enums");
const segmentIndicesCache = new Map();
const setSegmentationDirty = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = true;
    }
};
exports.setSegmentationDirty = setSegmentationDirty;
const setSegmentationClean = (segmentationId) => {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached) {
        cached.isDirty = false;
    }
};
exports.setSegmentationClean = setSegmentationClean;
function getCachedSegmentIndices(segmentationId) {
    const cached = segmentIndicesCache.get(segmentationId);
    if (cached && !cached.isDirty) {
        return cached.indices;
    }
    return null;
}
function getUniqueSegmentIndices(segmentationId) {
    const cachedResult = getCachedSegmentIndices(segmentationId);
    if (cachedResult) {
        return cachedResult;
    }
    const segmentation = (0, segmentationState_1.getSegmentation)(segmentationId);
    if (!segmentation) {
        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);
    }
    let indices;
    switch (segmentation.type) {
        case enums_1.SegmentationRepresentations.Labelmap:
            indices = handleLabelmapSegmentation(segmentation, segmentationId);
            break;
        case enums_1.SegmentationRepresentations.Contour:
            indices = handleContourSegmentation(segmentation);
            break;
        case enums_1.SegmentationRepresentations.Surface:
            indices = handleSurfaceSegmentation(segmentation);
            break;
        default:
            throw new Error(`Unsupported segmentation type: ${segmentation.type}`);
    }
    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });
    return indices;
}
exports.getUniqueSegmentIndices = getUniqueSegmentIndices;
function handleLabelmapSegmentation(segmentation, segmentationId) {
    const labelmapData = segmentation.representationData[enums_1.SegmentationRepresentations.Labelmap];
    const keySet = new Set();
    if ((0, stackVolumeCheck_1.isVolumeSegmentation)(labelmapData)) {
        addVolumeSegmentIndices(keySet, segmentationId);
    }
    else {
        addImageSegmentIndices(keySet, labelmapData.imageIdReferenceMap);
    }
    return Array.from(keySet)
        .map(Number)
        .sort((a, b) => a - b);
}
function addVolumeSegmentIndices(keySet, segmentationId) {
    const volume = core_1.cache.getVolume(segmentationId);
    const scalarData = volume.getScalarData();
    scalarData.forEach((segmentIndex) => {
        if (segmentIndex !== 0) {
            keySet.add(segmentIndex);
        }
    });
}
function addImageSegmentIndices(keySet, imageIdReferenceMap) {
    imageIdReferenceMap.forEach((segmentationImageId) => {
        const image = core_1.cache.getImage(segmentationImageId);
        const scalarData = image.getPixelData();
        scalarData.forEach((segmentIndex) => {
            if (segmentIndex !== 0) {
                keySet.add(segmentIndex);
            }
        });
    });
}
function handleContourSegmentation(segmentation) {
    const { annotationUIDsMap, geometryIds } = segmentation.representationData.CONTOUR || {};
    if (!geometryIds) {
        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);
    }
    const indices = new Set([...annotationUIDsMap.keys()]);
    geometryIds.forEach((geometryId) => {
        const geometry = core_1.cache.getGeometry(geometryId);
        indices.add(geometry.data.getSegmentIndex());
    });
    return Array.from(indices).sort((a, b) => a - b);
}
function handleSurfaceSegmentation(segmentation) {
    var _a, _b;
    const geometryIds = (_b = (_a = segmentation.representationData.SURFACE) === null || _a === void 0 ? void 0 : _a.geometryIds) !== null && _b !== void 0 ? _b : [];
    return Array.from(geometryIds.keys())
        .map(Number)
        .sort((a, b) => a - b);
}
//# sourceMappingURL=getUniqueSegmentIndices.js.map