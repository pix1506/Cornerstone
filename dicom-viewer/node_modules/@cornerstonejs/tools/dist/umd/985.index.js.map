{"version":3,"file":"985.index.js","mappings":"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","sources":["webpack://cornerstoneTools3D/webpack/universalModuleDefinition","webpack://cornerstoneTools3D/webpack/runtime/chunk loaded","webpack://cornerstoneTools3D/webpack/runtime/startup chunk dependencies","webpack://cornerstoneTools3D/./src/utilities/boundingBox/getBoundingBoxAroundShape.ts","webpack://cornerstoneTools3D/./src/utilities/pointInShapeCallback.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/projectTo2D.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/containsPoint.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/isClosed.ts","webpack://cornerstoneTools3D/./src/utilities/math/point/distanceToPointSquared.ts","webpack://cornerstoneTools3D/./src/utilities/math/polyline/getAABB.ts","webpack://cornerstoneTools3D/./src/utilities/planar/isPlaneIntersectingAABB.ts","webpack://cornerstoneTools3D/./src/workers/polySegConverters.js","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/Core/DataArray\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/ImageData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/Plane\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Common/DataModel/PolyData\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/Core/Cutter\"","webpack://cornerstoneTools3D/external umd \"@kitware/vtk.js/Filters/General/ContourLoopExtraction\"","webpack://cornerstoneTools3D/external umd {\"root\":\"cornerstone3D\",\"commonjs\":\"@cornerstonejs/core\",\"commonjs2\":\"@cornerstonejs/core\",\"amd\":\"@cornerstonejs/core\"}","webpack://cornerstoneTools3D/external umd {\"root\":\"window\",\"commonjs\":\"gl-matrix\",\"commonjs2\":\"gl-matrix\",\"amd\":\"gl-matrix\"}","webpack://cornerstoneTools3D/webpack/bootstrap","webpack://cornerstoneTools3D/webpack/runtime/compat get default export","webpack://cornerstoneTools3D/webpack/runtime/define property getters","webpack://cornerstoneTools3D/webpack/runtime/ensure chunk","webpack://cornerstoneTools3D/webpack/runtime/get javascript chunk filename","webpack://cornerstoneTools3D/webpack/runtime/global","webpack://cornerstoneTools3D/webpack/runtime/hasOwnProperty shorthand","webpack://cornerstoneTools3D/webpack/runtime/publicPath","webpack://cornerstoneTools3D/webpack/runtime/importScripts chunk loading","webpack://cornerstoneTools3D/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/Plane\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Filters/General/ContourLoopExtraction\"), require(\"@kitware/vtk.js/Filters/Core/Cutter\"), require(\"gl-matrix\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@kitware/vtk.js/Common/DataModel/ImageData\", \"@kitware/vtk.js/Common/Core/DataArray\", \"@cornerstonejs/core\", \"@kitware/vtk.js/Common/DataModel/Plane\", \"@kitware/vtk.js/Common/DataModel/PolyData\", \"@kitware/vtk.js/Filters/General/ContourLoopExtraction\", \"@kitware/vtk.js/Filters/Core/Cutter\", \"gl-matrix\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"cornerstoneTools3D\"] = factory(require(\"@kitware/vtk.js/Common/DataModel/ImageData\"), require(\"@kitware/vtk.js/Common/Core/DataArray\"), require(\"@cornerstonejs/core\"), require(\"@kitware/vtk.js/Common/DataModel/Plane\"), require(\"@kitware/vtk.js/Common/DataModel/PolyData\"), require(\"@kitware/vtk.js/Filters/General/ContourLoopExtraction\"), require(\"@kitware/vtk.js/Filters/Core/Cutter\"), require(\"gl-matrix\"));\n\telse\n\t\troot[\"cornerstoneTools3D\"] = factory(root[\"@kitware/vtk.js/Common/DataModel/ImageData\"], root[\"@kitware/vtk.js/Common/Core/DataArray\"], root[\"cornerstone3D\"], root[\"@kitware/vtk.js/Common/DataModel/Plane\"], root[\"@kitware/vtk.js/Common/DataModel/PolyData\"], root[\"@kitware/vtk.js/Filters/General/ContourLoopExtraction\"], root[\"@kitware/vtk.js/Filters/Core/Cutter\"], root[\"window\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__283__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__953__, __WEBPACK_EXTERNAL_MODULE__864__, __WEBPACK_EXTERNAL_MODULE__70__, __WEBPACK_EXTERNAL_MODULE__336__, __WEBPACK_EXTERNAL_MODULE__481__, __WEBPACK_EXTERNAL_MODULE__976__) => {\nreturn ","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(78).then(next);\n};","import type { Types } from '@cornerstonejs/core';\nimport { CONSTANTS } from '@cornerstonejs/core';\n\nconst { EPSILON } = CONSTANTS;\n\n/** Bounding box type */\ntype BoundingBox =\n  | [Types.Point2, Types.Point2, null]\n  | [Types.Point2, Types.Point2, Types.Point2];\n\nfunction calculateBoundingBox(\n  points,\n  dimensions,\n  isWorld = false\n): BoundingBox {\n  let xMin = Infinity;\n  let xMax = isWorld ? -Infinity : 0;\n  let yMin = Infinity;\n  let yMax = isWorld ? -Infinity : 0;\n  let zMin = Infinity;\n  let zMax = isWorld ? -Infinity : 0;\n\n  const is3D = points[0]?.length === 3;\n\n  // use for loop for performance\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    xMin = Math.min(p[0], xMin);\n    xMax = Math.max(p[0], xMax);\n    yMin = Math.min(p[1], yMin);\n    yMax = Math.max(p[1], yMax);\n\n    if (is3D) {\n      zMin = Math.min(p[2] ?? zMin, zMin);\n      zMax = Math.max(p[2] ?? zMax, zMax);\n    }\n  }\n\n  if (dimensions) {\n    xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n    xMax = Math.min(\n      isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1,\n      xMax\n    );\n    yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n    yMax = Math.min(\n      isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1,\n      yMax\n    );\n\n    if (is3D && dimensions.length === 3) {\n      zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n      zMax = Math.min(\n        isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1,\n        zMax\n      );\n    }\n  } else if (!isWorld) {\n    // still need to bound to 0 and Infinity if no dimensions are provided for ijk\n    xMin = Math.max(0, xMin);\n    xMax = Math.min(Infinity, xMax);\n    yMin = Math.max(0, yMin);\n    yMax = Math.min(Infinity, yMax);\n\n    if (is3D) {\n      zMin = Math.max(0, zMin);\n      zMax = Math.min(Infinity, zMax);\n    }\n  }\n\n  return is3D\n    ? [\n        [xMin, xMax],\n        [yMin, yMax],\n        [zMin, zMax],\n      ]\n    : [[xMin, xMax], [yMin, yMax], null];\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in IJK, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param dimensions - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeIJK(\n  points: Types.Point2[] | Types.Point3[],\n  dimensions?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, dimensions, false);\n}\n\n/**\n * With a given vertices (points) coordinates in 2D or 3D in World Coordinates, it calculates the minimum and maximum\n * coordinate in each axis, and returns them. If clipBounds are provided it also\n * clip the min, max to the provided width, height and depth\n *\n * @param points - shape corner points coordinates either in IJK (image coordinate)\n * @param clipBounds - bounds to clip the min, max\n * @returns [[xMin,xMax],[yMin,yMax], [zMin,zMax]]\n */\nexport function getBoundingBoxAroundShapeWorld(\n  points: Types.Point2[] | Types.Point3[],\n  clipBounds?: Types.Point2 | Types.Point3\n): BoundingBox {\n  return calculateBoundingBox(points, clipBounds, true);\n}\n","import { vec3 } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport type { vtkImageData } from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport BoundsIJK from '../types/BoundsIJK';\n\nexport type PointInShape = {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3 | number[];\n};\n\nexport type PointInShapeCallback = ({\n  value,\n  index,\n  pointIJK,\n  pointLPS,\n}: {\n  value: number;\n  index: number;\n  pointIJK: vec3;\n  pointLPS: vec3;\n}) => void;\n\nexport type ShapeFnCriteria = (pointLPS: vec3, pointIJK: vec3) => boolean;\n\n/**\n * For each point in the image (If boundsIJK is not provided, otherwise, for each\n * point in the provided bounding box), It runs the provided callback IF the point\n * passes the provided criteria to be inside the shape (which is defined by the\n * provided pointInShapeFn)\n *\n * @param imageData - The image data object.\n * @param dimensions - The dimensions of the image.\n * @param pointInShapeFn - A function that takes a point in LPS space and returns\n * true if the point is in the shape and false if it is not.\n * @param callback - A function that will be called for\n * every point in the shape.\n * @param boundsIJK - The bounds of the volume in IJK coordinates.\n */\nexport default function pointInShapeCallback(\n  imageData: vtkImageData | Types.CPUImageData,\n  pointInShapeFn: ShapeFnCriteria,\n  callback?: PointInShapeCallback,\n  boundsIJK?: BoundsIJK\n): Array<PointInShape> {\n  let iMin, iMax, jMin, jMax, kMin, kMax;\n\n  let scalarData;\n  const { numComps } = imageData as any;\n\n  // if getScalarData is a method on imageData\n  if ((imageData as Types.CPUImageData).getScalarData) {\n    scalarData = (imageData as Types.CPUImageData).getScalarData();\n  } else {\n    scalarData = (imageData as vtkImageData)\n      .getPointData()\n      .getScalars()\n      .getData();\n  }\n\n  if (!scalarData) {\n    console.warn('No scalar data found for imageData', imageData);\n    return;\n  }\n\n  const dimensions = imageData.getDimensions();\n\n  if (!boundsIJK) {\n    iMin = 0;\n    iMax = dimensions[0];\n    jMin = 0;\n    jMax = dimensions[1];\n    kMin = 0;\n    kMax = dimensions[2];\n  } else {\n    [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = boundsIJK;\n  }\n\n  const start = vec3.fromValues(iMin, jMin, kMin);\n\n  const direction = imageData.getDirection();\n  const rowCosines = direction.slice(0, 3);\n  const columnCosines = direction.slice(3, 6);\n  const scanAxisNormal = direction.slice(6, 9);\n\n  const spacing = imageData.getSpacing();\n  const [rowSpacing, columnSpacing, scanAxisSpacing] = spacing;\n\n  // @ts-ignore will be fixed in vtk-master\n  const worldPosStart = imageData.indexToWorld(start);\n\n  const rowStep = vec3.fromValues(\n    rowCosines[0] * rowSpacing,\n    rowCosines[1] * rowSpacing,\n    rowCosines[2] * rowSpacing\n  );\n\n  const columnStep = vec3.fromValues(\n    columnCosines[0] * columnSpacing,\n    columnCosines[1] * columnSpacing,\n    columnCosines[2] * columnSpacing\n  );\n\n  const scanAxisStep = vec3.fromValues(\n    scanAxisNormal[0] * scanAxisSpacing,\n    scanAxisNormal[1] * scanAxisSpacing,\n    scanAxisNormal[2] * scanAxisSpacing\n  );\n\n  const xMultiple =\n    numComps ||\n    scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n  const yMultiple = dimensions[0] * xMultiple;\n  const zMultiple = dimensions[1] * yMultiple;\n\n  const pointsInShape: Array<PointInShape> = [];\n\n  const currentPos = vec3.clone(worldPosStart);\n\n  for (let k = kMin; k <= kMax; k++) {\n    const startPosJ = vec3.clone(currentPos);\n\n    for (let j = jMin; j <= jMax; j++) {\n      const startPosI = vec3.clone(currentPos);\n\n      for (let i = iMin; i <= iMax; i++) {\n        const pointIJK: Types.Point3 = [i, j, k];\n\n        // The current world position (pointLPS) is now in currentPos\n        if (pointInShapeFn(currentPos as Types.Point3, pointIJK)) {\n          const index = k * zMultiple + j * yMultiple + i * xMultiple;\n          let value;\n          if (xMultiple > 2) {\n            value = [\n              scalarData[index],\n              scalarData[index + 1],\n              scalarData[index + 2],\n            ];\n          } else {\n            value = scalarData[index];\n          }\n\n          pointsInShape.push({\n            value,\n            index,\n            pointIJK,\n            pointLPS: currentPos.slice(),\n          });\n          if (callback) {\n            callback({ value, index, pointIJK, pointLPS: currentPos });\n          }\n        }\n\n        // Increment currentPos by rowStep for the next iteration\n        vec3.add(currentPos, currentPos, rowStep);\n      }\n\n      // Reset currentPos to the start of the next J line and increment by columnStep\n      vec3.copy(currentPos, startPosI);\n      vec3.add(currentPos, currentPos, columnStep);\n    }\n\n    // Reset currentPos to the start of the next K slice and increment by scanAxisStep\n    vec3.copy(currentPos, startPosJ);\n    vec3.add(currentPos, currentPos, scanAxisStep);\n  }\n\n  return pointsInShape;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport type { Types } from '@cornerstonejs/core';\n\nconst epsilon = 1e-6;\n\n/**\n * Projects a polyline from 3D to 2D by reducing one dimension.\n *\n * @param polyline - The polyline to be projected.\n * @returns An object containing the shared dimension index and the projected polyline in 2D.\n * @throws Error if a shared dimension index cannot be found for the polyline.\n */\nexport function projectTo2D(polyline: Types.Point3[]) {\n  // We need to reduce one dimension to 2D, so basically\n  // we need to find the dimension index that is shared by all points\n  // Use the first three points, two is enough but three is more robust\n  let sharedDimensionIndex;\n\n  const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n\n  for (let i = 0; i < 3; i++) {\n    if (\n      testPoints.every(\n        (point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon\n      )\n    ) {\n      sharedDimensionIndex = i;\n      break;\n    }\n  }\n\n  if (sharedDimensionIndex === undefined) {\n    throw new Error(\n      'Cannot find a shared dimension index for polyline, probably oblique plane'\n    );\n  }\n\n  // convert polyline list and point to 2D\n  const points2D = [] as Types.Point2[];\n\n  const firstDim = (sharedDimensionIndex + 1) % 3;\n  const secondDim = (sharedDimensionIndex + 2) % 3;\n\n  for (let i = 0; i < polyline.length; i++) {\n    points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n  }\n\n  return {\n    sharedDimensionIndex,\n    projectedPolyline: points2D,\n  };\n}\n","import type { Types } from '@cornerstonejs/core';\nimport isClosed from './isClosed';\n\n/**\n * Checks if a 2D point is inside the polyline.\n *\n * A point is inside a curve/polygon if the number of intersections between the horizontal\n * ray emanating from the given point and to the right and the line segments is odd.\n * https://www.eecs.umich.edu/courses/eecs380/HANDOUTS/PROJ2/InsidePoly.html\n *\n * Note that a point on the polyline is considered inside.\n *\n * @param polyline - Polyline points (2D)\n * @param point - 2D Point\n * @returns True if the point is inside the polyline or false otherwise\n */\nexport default function containsPoint(\n  polyline: Types.Point2[],\n  point: Types.Point2,\n  options: {\n    closed?: boolean;\n    holes?: Types.Point2[][];\n  } = {\n    closed: undefined,\n  }\n): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n  let numIntersections = 0;\n\n  const { closed, holes } = options;\n\n  if (holes?.length) {\n    for (const hole of holes) {\n      if (containsPoint(hole, point)) {\n        return false;\n      }\n    }\n  }\n\n  // Test intersection against [end, start] line segment if it should be closed\n  const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n  const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n\n  for (let i = 0; i <= maxSegmentIndex; i++) {\n    const p1 = polyline[i];\n\n    // Calculating the next point index without using % (mod) operator like in\n    // `(i + 1) % numPolylinePoints` to make it 20% faster\n    const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n    const p2 = polyline[p2Index];\n\n    // Calculating min/max without using Math.min/max to make it ~3% faster\n    const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n    const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n    const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n\n    const mayIntersectLineSegment =\n      point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n\n    if (mayIntersectLineSegment) {\n      const isVerticalLine = p1[0] === p2[0];\n      let intersects = isVerticalLine;\n\n      if (!intersects) {\n        const xIntersection =\n          ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n\n        intersects = point[0] <= xIntersection;\n      }\n\n      numIntersections += intersects ? 1 : 0;\n    }\n  }\n\n  return !!(numIntersections % 2);\n}\n","import { glMatrix } from 'gl-matrix';\nimport type { Types } from '@cornerstonejs/core';\nimport * as math from '..';\n\n/**\n * A polyline is considered closed if the start and end points are at the same position\n *\n * @param polyline - Polyline points (2D)\n * @returns True if the polyline is already closed or false otherwise\n */\nexport default function isClosed(polyline: Types.Point2[]): boolean {\n  if (polyline.length < 3) {\n    return false;\n  }\n\n  const numPolylinePoints = polyline.length;\n\n  const firstPoint = polyline[0];\n  const lastPoint = polyline[numPolylinePoints - 1];\n  const distFirstToLastPoints = math.point.distanceToPointSquared(\n    firstPoint,\n    lastPoint\n  );\n\n  return glMatrix.equals(0, distFirstToLastPoints);\n}\n","import type { Types } from '@cornerstonejs/core';\n\ntype Point = Types.Point2 | Types.Point3;\n\n/**\n * Calculates the distance squared of a point to another point\n *\n * @param p1 - x,y or x,y,z of the point\n * @param p2 - x,y or x,y,z of the point\n * @returns distance\n */\nexport default function distanceToPointSquared(p1: Point, p2: Point): number {\n  if (p1.length !== p2.length) {\n    throw Error('Both points should have the same dimensionality');\n  }\n\n  const [x1, y1, z1 = 0] = p1;\n  const [x2, y2, z2 = 0] = p2;\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const dz = z2 - z1;\n\n  // Time to square 10M numbers:\n  //   (n * n) = 161ms | (n ** 2) = 199ms | Math.pow(n, 2) = 29529ms\n  return dx * dx + dy * dy + dz * dz;\n}\n","import { Types } from '@cornerstonejs/core';\n\n/**\n * Calculates the axis-aligned bounding box (AABB) of a polyline.\n *\n * @param polyline - The polyline represented as an array of points.\n * @param options - Additional options for calculating the AABB.\n * @param options.isWorld - Indicates whether the polyline represents points in 3D space (true) or 2D space (false).\n *\n * @returns The AABB of the polyline. If the polyline represents points in 3D space, returns an AABB3 object with properties minX, maxX, minY, maxY, minZ, and maxZ. If the polyline represents points in 2D space, returns an AABB2 object with properties minX, maxX, minY, and maxY.\n */\nexport default function getAABB(\n  polyline: Types.Point2[] | Types.Point3[] | number[],\n  options?: {\n    numDimensions: number;\n  }\n): Types.AABB2 | Types.AABB3 {\n  // need to check if the polyline is array of arrays or just\n  // a flat array of numbers\n  let polylineToUse = polyline;\n  const numDimensions = options?.numDimensions || 2;\n  const is3D = numDimensions === 3;\n\n  if (!Array.isArray(polyline[0])) {\n    const currentPolyline = polyline as number[];\n    // check the isWorld flag is provided or not which means every\n    // 3 elements in the array represent a point in 3D space\n    // otherwise, every 2 elements in the array represent a point in 2D space\n    const totalPoints = currentPolyline.length / numDimensions;\n\n    polylineToUse = new Array(currentPolyline.length / numDimensions) as\n      | Types.Point2[]\n      | Types.Point3[];\n\n    for (let i = 0, len = totalPoints; i < len; i++) {\n      polylineToUse[i] = [\n        currentPolyline[i * numDimensions],\n        currentPolyline[i * numDimensions + 1],\n      ];\n\n      if (is3D) {\n        polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);\n      }\n    }\n  }\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let minZ = Infinity;\n  let maxZ = -Infinity;\n\n  polylineToUse = polylineToUse as Types.Point2[] | Types.Point3[];\n\n  for (let i = 0, len = polylineToUse.length; i < len; i++) {\n    const [x, y, z] = polylineToUse[i];\n\n    // No Math.min/max calls for better performance\n    minX = minX < x ? minX : x;\n    minY = minY < y ? minY : y;\n    maxX = maxX > x ? maxX : x;\n    maxY = maxY > y ? maxY : y;\n\n    if (is3D) {\n      minZ = minZ < z ? minZ : z;\n      maxZ = maxZ > z ? maxZ : z;\n    }\n  }\n\n  return is3D\n    ? { minX, maxX, minY, maxY, minZ, maxZ } // AABB3\n    : { minX, maxX, minY, maxY }; // AABB2\n}\n","import { vec3 } from 'gl-matrix';\n\n/**\n * Checks if a plane intersects with an Axis-Aligned Bounding Box (AABB).\n *\n * @param origin - The origin point of the plane.\n * @param normal - The normal vector of the plane.\n * @param minX - The minimum x-coordinate of the AABB.\n * @param minY - The minimum y-coordinate of the AABB.\n * @param minZ - The minimum z-coordinate of the AABB.\n * @param maxX - The maximum x-coordinate of the AABB.\n * @param maxY - The maximum y-coordinate of the AABB.\n * @param maxZ - The maximum z-coordinate of the AABB.\n * @returns A boolean indicating whether the plane intersects with the AABB.\n */\nexport const isPlaneIntersectingAABB = (\n  origin,\n  normal,\n  minX,\n  minY,\n  minZ,\n  maxX,\n  maxY,\n  maxZ\n) => {\n  const vertices = [\n    vec3.fromValues(minX, minY, minZ),\n    vec3.fromValues(maxX, minY, minZ),\n    vec3.fromValues(minX, maxY, minZ),\n    vec3.fromValues(maxX, maxY, minZ),\n    vec3.fromValues(minX, minY, maxZ),\n    vec3.fromValues(maxX, minY, maxZ),\n    vec3.fromValues(minX, maxY, maxZ),\n    vec3.fromValues(maxX, maxY, maxZ),\n  ];\n\n  const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n  const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n\n  // Compute the distance from the plane to the origin using vec3.dot\n  const planeDistance = -vec3.dot(normalVec, originVec);\n\n  // Check if all vertices are on the same side of the plane\n  let initialSign = null;\n  for (const vertex of vertices) {\n    // Calculate distance using vec3.dot to simplify the equation\n    const distance = vec3.dot(normalVec, vertex) + planeDistance;\n    if (initialSign === null) {\n      initialSign = Math.sign(distance);\n    } else if (Math.sign(distance) !== initialSign) {\n      return true; // Found a vertex on the other side, so it intersects\n    }\n  }\n\n  return false;\n};\n","import { expose } from 'comlink';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport ICRPolySeg from '@icr/polyseg-wasm';\nimport { utilities } from '@cornerstonejs/core';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\n\nimport { getBoundingBoxAroundShapeWorld } from '../utilities/boundingBox';\nimport { pointInShapeCallback } from '../utilities';\nimport {\n  containsPoint,\n  getAABB,\n  projectTo2D,\n} from '../utilities/math/polyline';\nimport { isPlaneIntersectingAABB } from '../utilities/planar';\n\n/**\n * Object containing methods for converting between different representations of\n * segmentations (e.g., contour, labelmap, surface, etc.) These logics\n * are used in a webworker to avoid blocking the main thread. You can\n * search for workerManager.executeTask('polySeg', ...) to see\n * how these methods are used.\n *\n * See also the webworker docs at packages/docs/docs/concepts/cornerstone-core/web-worker.md\n * to learn more about how to use webworkers in the context of Cornerstone.\n */\nconst polySegConverters = {\n  /**\n   * The polySeg instance that is used to convert between different representations\n   */\n  polySeg: null,\n  /**\n   * Utilities to keep track of the initialization state of the polySeg instance\n   * and avoid initializing it multiple times\n   */\n  polySegInitializing: false,\n  polySegInitializingPromise: null,\n  /**\n   * This method initializes the polySeg instance and sets it to this.polySeg\n   */\n  async initializePolySeg(progressCallback) {\n    if (this.polySegInitializing) {\n      await this.polySegInitializingPromise;\n      return;\n    }\n\n    if (this.polySeg?.instance) {\n      return;\n    }\n\n    this.polySegInitializing = true;\n    this.polySegInitializingPromise = new Promise((resolve) => {\n      this.polySeg = new ICRPolySeg();\n      this.polySeg\n        .initialize({\n          updateProgress: progressCallback,\n        })\n        .then(() => {\n          this.polySegInitializing = false;\n          resolve();\n        });\n    });\n\n    await this.polySegInitializingPromise;\n  },\n  /**\n   * Converts a contour to a surface using the PolySeg library.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.polylines - The polylines representing the contour.\n   * @param {Array} args.numPointsArray - The number of points in each polyline.\n   * @param {...Function} callbacks - Optional callback functions.\n   * @returns {Promise} - A promise that resolves to the converted surface.\n   */\n  async convertContourToSurface(args, ...callbacks) {\n    const { polylines, numPointsArray } = args;\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n    const results = await this.polySeg.instance.convertContourRoiToSurface(\n      polylines,\n      numPointsArray\n    );\n\n    return results;\n  },\n  /**\n   * Converts a labelmap to a surface using the specified arguments.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.scalarData - The scalar data of the labelmap.\n   * @param {Array} args.dimensions - The dimensions of the labelmap.\n   * @param {Array} args.spacing - The spacing of the labelmap.\n   * @param {Array} args.direction - The direction of the labelmap.\n   * @param {Array} args.origin - The origin of the labelmap.\n   * @param {number} args.segmentIndex - The segment index of the labelmap.\n   * @param {Function} progressCallback - The callback function for progress updates.\n   * @returns {Promise} - A promise that resolves with the converted surface results.\n   */\n  async convertLabelmapToSurface(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const results = this.polySeg.instance.convertLabelmapToSurface(\n      args.scalarData,\n      args.dimensions,\n      args.spacing,\n      args.direction,\n      args.origin,\n      [args.segmentIndex]\n    );\n    return results;\n  },\n  /**\n   * Converts a contour to a volume labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.segmentIndices - The indices of the segments.\n   * @param {Array} args.scalarData - The scalar data.\n   * @param {Map} args.annotationUIDsInSegmentMap - The map of annotation UIDs in segment.\n   * @param {Array} args.dimensions - The dimensions of the image data.\n   * @param {Array} args.origin - The origin of the image data.\n   * @param {Array} args.direction - The direction of the image data.\n   * @param {Array} args.spacing - The spacing of the image data.\n   * @param {...Function} callbacks - Optional callbacks.\n   * @param {Function} callbacks[0] - The progress callback.\n   * @returns {Array} - The scalar data of the segmentation voxel manager.\n   */\n  async convertContourToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    const polySeg = await new ICRPolySeg();\n    await polySeg.initialize({\n      updateProgress: progressCallback,\n    });\n\n    const {\n      segmentIndices,\n      scalarData,\n      annotationUIDsInSegmentMap,\n      dimensions,\n      origin,\n      direction,\n      spacing,\n    } = args;\n\n    const segmentationVoxelManager =\n      utilities.VoxelManager.createVolumeVoxelManager(dimensions, scalarData);\n\n    const imageData = vtkImageData.newInstance();\n    imageData.setDimensions(dimensions);\n    imageData.setOrigin(origin);\n    imageData.setDirection(direction);\n    imageData.setSpacing(spacing);\n\n    const scalarArray = vtkDataArray.newInstance({\n      name: 'Pixels',\n      numberOfComponents: 1,\n      values: scalarData,\n    });\n\n    imageData.getPointData().setScalars(scalarArray);\n\n    imageData.modified();\n\n    for (const index of segmentIndices) {\n      const annotations = annotationUIDsInSegmentMap.get(index);\n\n      for (const annotation of annotations) {\n        if (!annotation.polyline) {\n          continue;\n        }\n\n        const { polyline, holesPolyline } = annotation;\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\n\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][0],\n          bounds[1][0],\n          bounds[2][0],\n        ]);\n\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][1],\n          bounds[1][1],\n          bounds[2][1],\n        ]);\n\n        const { projectedPolyline, sharedDimensionIndex } =\n          projectTo2D(polyline);\n\n        const holes = holesPolyline?.map((hole) => {\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\n          return projectedHole;\n        });\n\n        const firstDim = (sharedDimensionIndex + 1) % 3;\n        const secondDim = (sharedDimensionIndex + 2) % 3;\n\n        // Run the pointInShapeCallback for the combined bounding box\n        pointInShapeCallback(\n          imageData,\n          (pointLPS) => {\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n\n            // Check if the point is inside any of the polylines for this segment\n            const isInside = containsPoint(projectedPolyline, point2D, {\n              holes,\n            });\n\n            return isInside;\n          },\n          ({ pointIJK }) => {\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n          },\n          [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n          ]\n        );\n      }\n    }\n\n    return segmentationVoxelManager.scalarData;\n  },\n  /**\n   * Converts a contour to a stack labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} callbacks - Optional callbacks for progress updates.\n   * @returns {Promise<Object>} - The converted segmentations information.\n   */\n  async convertContourToStackLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    const polySeg = await new ICRPolySeg();\n    await polySeg.initialize({\n      updateProgress: progressCallback,\n    });\n\n    const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } =\n      args;\n\n    const segmentationVoxelManagers = new Map();\n\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n      const { dimensions, scalarData, direction, spacing, origin } =\n        segmentationInfo;\n      const manager = utilities.VoxelManager.createVolumeVoxelManager(\n        dimensions,\n        scalarData\n      );\n\n      const imageData = vtkImageData.newInstance();\n      imageData.setDimensions(dimensions);\n      imageData.setOrigin(origin);\n      imageData.setDirection(direction);\n      imageData.setSpacing(spacing);\n\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: scalarData,\n      });\n\n      imageData.getPointData().setScalars(scalarArray);\n\n      imageData.modified();\n\n      segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\n    });\n\n    for (const index of segmentIndices) {\n      const annotations = annotationUIDsInSegmentMap.get(index);\n\n      for (const annotation of annotations) {\n        if (!annotation.polyline) {\n          continue;\n        }\n\n        const { polyline, holesPolyline, referencedImageId } = annotation;\n        const bounds = getBoundingBoxAroundShapeWorld(polyline);\n\n        const { manager: segmentationVoxelManager, imageData } =\n          segmentationVoxelManagers.get(referencedImageId);\n\n        const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][0],\n          bounds[1][0],\n          bounds[2][0],\n        ]);\n\n        const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n          bounds[0][1],\n          bounds[1][1],\n          bounds[2][1],\n        ]);\n\n        const { projectedPolyline, sharedDimensionIndex } =\n          projectTo2D(polyline);\n\n        const holes = holesPolyline?.map((hole) => {\n          const { projectedPolyline: projectedHole } = projectTo2D(hole);\n          return projectedHole;\n        });\n\n        const firstDim = (sharedDimensionIndex + 1) % 3;\n        const secondDim = (sharedDimensionIndex + 2) % 3;\n\n        // Run the pointInShapeCallback for the combined bounding box\n        pointInShapeCallback(\n          imageData,\n          (pointLPS) => {\n            const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n\n            // Check if the point is inside any of the polylines for this segment\n            const isInside = containsPoint(projectedPolyline, point2D, {\n              holes,\n            });\n\n            return isInside;\n          },\n          ({ pointIJK }) => {\n            segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n          },\n          [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n          ]\n        );\n      }\n    }\n\n    segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n      const { manager: segmentationVoxelManager } =\n        segmentationVoxelManagers.get(referencedImageId);\n\n      segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\n    });\n    return segmentationsInfo;\n  },\n  /**\n   * Converts a surface to a volume labelmap.\n   *\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Array} args.points - The points defining the surface.\n   * @param {Array} args.polys - The polygons defining the surface.\n   * @param {Array} args.dimensions - The dimensions of the volume.\n   * @param {Array} args.spacing - The spacing between voxels in the volume.\n   * @param {Array} args.direction - The direction of the volume.\n   * @param {Array} args.origin - The origin of the volume.\n   * @param {Function} progressCallback - The callback function for reporting progress.\n   * @returns {Promise} - A promise that resolves with the converted labelmap.\n   */\n  async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const results = this.polySeg.instance.convertSurfaceToLabelmap(\n      args.points,\n      args.polys,\n      args.dimensions,\n      args.spacing,\n      args.direction,\n      args.origin\n    );\n\n    return results;\n  },\n  /**\n   * Converts surfaces to a volume labelmap.\n   * @param {Object} args - The arguments for the conversion.\n   * @param {Map} args.segmentsInfo - A map containing information about the segments.\n   * @param {Function} progressCallback - A callback function for reporting progress.\n   * @returns {Uint8Array} - The resulting volume labelmap.\n   */\n  async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\n    const [progressCallback] = callbacks;\n    await this.initializePolySeg(progressCallback);\n\n    const { segmentsInfo } = args;\n\n    const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\n      const { points, polys } = segmentsInfo.get(segmentIndex);\n      const result = this.polySeg.instance.convertSurfaceToLabelmap(\n        points,\n        polys,\n        args.dimensions,\n        args.spacing,\n        args.direction,\n        args.origin\n      );\n\n      return {\n        ...result,\n        segmentIndex,\n      };\n    });\n\n    const results = await Promise.all(promises);\n\n    const targetImageData = vtkImageData.newInstance();\n    targetImageData.setDimensions(args.dimensions);\n    targetImageData.setOrigin(args.origin);\n    targetImageData.setSpacing(args.spacing);\n    targetImageData.setDirection(args.direction);\n\n    const totalSize =\n      args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\n\n    const scalarArray = vtkDataArray.newInstance({\n      name: 'Pixels',\n      numberOfComponents: 1,\n      values: new Uint8Array(totalSize),\n    });\n\n    targetImageData.getPointData().setScalars(scalarArray);\n    targetImageData.modified();\n\n    // we need to then consolidate the results into a single volume\n    // by looping into each voxel with pointInShapeCallback\n    // and check if the voxel is inside any of the reconstructed\n    // labelmaps\n\n    const segmentationVoxelManager =\n      utilities.VoxelManager.createVolumeVoxelManager(\n        args.dimensions,\n        targetImageData.getPointData().getScalars().getData()\n      );\n\n    const outputVolumesInfo = results.map((result) => {\n      const { data, dimensions, direction, origin, spacing } = result;\n      const volume = vtkImageData.newInstance();\n      volume.setDimensions(dimensions);\n      volume.setOrigin(origin);\n      volume.setSpacing(spacing);\n      volume.setDirection(direction);\n\n      const scalarArray = vtkDataArray.newInstance({\n        name: 'Pixels',\n        numberOfComponents: 1,\n        values: data,\n      });\n\n      volume.getPointData().setScalars(scalarArray);\n\n      volume.modified();\n\n      const voxelManager = utilities.VoxelManager.createVolumeVoxelManager(\n        dimensions,\n        data\n      );\n\n      const extent = volume.getExtent(); // e.g., [0, 176, 0, 268, 0, 337] for dimensions of [177, 269, 338]\n\n      return {\n        volume,\n        voxelManager,\n        extent,\n        scalarData: data,\n        segmentIndex: result.segmentIndex,\n      };\n    });\n\n    pointInShapeCallback(\n      targetImageData,\n      () => true, // we want to loop into all voxels\n      ({ pointIJK, pointLPS }) => {\n        // Check if the point is inside any of the reconstructed labelmaps\n        // Todo: we can optimize this by returning early if the bounding box\n        // of the point is outside the bounding box of the labelmap\n\n        try {\n          for (const volumeInfo of outputVolumesInfo) {\n            const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\n\n            const index = volume.worldToIndex(pointLPS);\n\n            // check if the ijk point is inside the volume\n            if (\n              index[0] < extent[0] ||\n              index[0] > extent[1] ||\n              index[1] < extent[2] ||\n              index[1] > extent[3] ||\n              index[2] < extent[4] ||\n              index[2] > extent[5]\n            ) {\n              continue;\n            }\n\n            const roundedIndex = index.map(Math.round);\n            const value = voxelManager.getAtIJK(...roundedIndex);\n            if (value > 0) {\n              segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\n              break;\n            }\n          }\n        } catch (error) {\n          // right now there is weird error if the point is outside the volume\n        }\n      }\n    );\n\n    return segmentationVoxelManager.scalarData;\n  },\n  getSurfacesAABBs({ surfacesInfo }) {\n    const aabbs = new Map();\n    for (const { points, id } of surfacesInfo) {\n      const aabb = getAABB(points, { numDimensions: 3 });\n      aabbs.set(id, aabb);\n    }\n    return aabbs;\n  },\n  /**\n   * Cuts the surfaces into planes.\n   *\n   * @param {Object} options - The options object.\n   * @param {Array} options.planesInfo - The information about the planes.\n   * @param {Array} options.surfacesInfo - The information about the surfaces.\n   * @param {Function} progressCallback - The callback function for progress updates.\n   * @param {Function} updateCacheCallback - The callback function for updating the cache.\n   */\n  cutSurfacesIntoPlanes(\n    { planesInfo, surfacesInfo, surfacesAABB = new Map() },\n    progressCallback,\n    updateCacheCallback\n  ) {\n    const numberOfPlanes = planesInfo.length;\n    const cutter = vtkCutter.newInstance();\n\n    const plane1 = vtkPlane.newInstance();\n\n    cutter.setCutFunction(plane1);\n\n    const surfacePolyData = vtkPolyData.newInstance();\n\n    try {\n      for (const [index, planeInfo] of planesInfo.entries()) {\n        const { sliceIndex, planes } = planeInfo;\n\n        const polyDataResults = new Map();\n        for (const polyDataInfo of surfacesInfo) {\n          const { points, polys, id } = polyDataInfo;\n\n          const aabb3 =\n            surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\n\n          if (!surfacesAABB.has(id)) {\n            surfacesAABB.set(id, aabb3);\n          }\n\n          const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\n\n          const { origin, normal } = planes[0];\n\n          // Check if the plane intersects the AABB\n          if (\n            !isPlaneIntersectingAABB(\n              origin,\n              normal,\n              minX,\n              minY,\n              minZ,\n              maxX,\n              maxY,\n              maxZ\n            )\n          ) {\n            continue;\n          }\n\n          surfacePolyData.getPoints().setData(points, 3);\n          surfacePolyData.getPolys().setData(polys, 3);\n          surfacePolyData.modified();\n\n          cutter.setInputData(surfacePolyData);\n          plane1.setOrigin(origin);\n          plane1.setNormal(normal);\n\n          try {\n            cutter.update();\n          } catch (e) {\n            console.warn('Error during clipping', e);\n            continue;\n          }\n\n          const polyData = cutter.getOutputData();\n\n          const cutterOutput = polyData;\n          cutterOutput.buildLinks();\n          const loopExtraction = vtkContourLoopExtraction.newInstance();\n          loopExtraction.setInputData(cutterOutput);\n\n          const loopOutput = loopExtraction.getOutputData();\n          if (polyData) {\n            polyDataResults.set(id, {\n              points: loopOutput.getPoints().getData(),\n              lines: loopOutput.getLines().getData(),\n              numberOfCells: loopOutput.getLines().getNumberOfCells(),\n            });\n          }\n        }\n\n        progressCallback({ progress: (index + 1) / numberOfPlanes });\n\n        updateCacheCallback({ sliceIndex, polyDataResults });\n      }\n    } catch (e) {\n      console.warn('Error during processing', e);\n    } finally {\n      // Cleanup on completion\n      surfacesInfo = null;\n      plane1.delete();\n    }\n  },\n};\n\nexpose(polySegConverters);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__785__;","module.exports = __WEBPACK_EXTERNAL_MODULE__283__;","module.exports = __WEBPACK_EXTERNAL_MODULE__864__;","module.exports = __WEBPACK_EXTERNAL_MODULE__70__;","module.exports = __WEBPACK_EXTERNAL_MODULE__481__;","module.exports = __WEBPACK_EXTERNAL_MODULE__336__;","module.exports = __WEBPACK_EXTERNAL_MODULE__953__;","module.exports = __WEBPACK_EXTERNAL_MODULE__976__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [78], () => (__webpack_require__(389)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".index.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t985: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkcornerstoneTools3D\"] = self[\"webpackChunkcornerstoneTools3D\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__283__","__WEBPACK_EXTERNAL_MODULE__785__","__WEBPACK_EXTERNAL_MODULE__953__","__WEBPACK_EXTERNAL_MODULE__864__","__WEBPACK_EXTERNAL_MODULE__70__","__WEBPACK_EXTERNAL_MODULE__336__","__WEBPACK_EXTERNAL_MODULE__481__","__WEBPACK_EXTERNAL_MODULE__976__","deferred","next","EPSILON","CONSTANTS","getBoundingBoxAroundShapeWorld","points","clipBounds","dimensions","_points$","isWorld","arguments","length","undefined","xMin","Infinity","xMax","yMin","yMax","zMin","zMax","is3D","i","p","_p$","_p$2","Math","min","max","calculateBoundingBox","pointInShapeCallback","imageData","pointInShapeFn","callback","boundsIJK","iMin","iMax","jMin","jMax","kMin","kMax","scalarData","numComps","getScalarData","getPointData","getScalars","getData","console","warn","getDimensions","start","vec3","direction","getDirection","rowCosines","slice","columnCosines","scanAxisNormal","spacing","getSpacing","rowSpacing","columnSpacing","scanAxisSpacing","worldPosStart","indexToWorld","rowStep","columnStep","scanAxisStep","xMultiple","yMultiple","zMultiple","pointsInShape","currentPos","k","startPosJ","j","startPosI","pointIJK","index","value","push","pointLPS","projectTo2D","polyline","sharedDimensionIndex","testPoints","utilities","every","point","array","abs","Error","points2D","firstDim","secondDim","projectedPolyline","containsPoint","options","closed","numPolylinePoints","numIntersections","holes","hole","shouldClose","distFirstToLastPoints","p1","p2","x1","y1","z1","x2","y2","z2","dx","dy","dz","math","glMatrix","isClosed","maxSegmentIndex","maxX","maxY","minY","intersects","xIntersection","getAABB","polylineToUse","numDimensions","Array","isArray","currentPolyline","totalPoints","len","minX","minZ","maxZ","x","y","z","isPlaneIntersectingAABB","origin","normal","vertices","normalVec","originVec","planeDistance","initialSign","vertex","distance","sign","polySegConverters","polySeg","polySegInitializing","polySegInitializingPromise","initializePolySeg","progressCallback","_this$polySeg","this","instance","Promise","resolve","ICRPolySeg","initialize","updateProgress","then","convertContourToSurface","args","polylines","numPointsArray","_len","callbacks","_key","convertContourRoiToSurface","convertLabelmapToSurface","_len2","_key2","segmentIndex","convertContourToVolumeLabelmap","_len3","_key3","segmentIndices","annotationUIDsInSegmentMap","segmentationVoxelManager","vtkImageData","setDimensions","setOrigin","setDirection","setSpacing","scalarArray","vtkDataArray","name","numberOfComponents","values","setScalars","modified","annotations","get","annotation","holesPolyline","bounds","map","projectedHole","point2D","_ref","setAtIJKPoint","convertContourToStackLabelmap","_len4","_key4","segmentationsInfo","segmentationVoxelManagers","Map","forEach","segmentationInfo","referencedImageId","manager","set","_ref2","convertSurfaceToVolumeLabelmap","_len5","_key5","convertSurfaceToLabelmap","polys","convertSurfacesToVolumeLabelmap","_len6","_key6","segmentsInfo","promises","from","keys","results","all","targetImageData","totalSize","Uint8Array","outputVolumesInfo","result","data","volume","voxelManager","extent","getExtent","_ref3","volumeInfo","worldToIndex","roundedIndex","round","getAtIJK","error","getSurfacesAABBs","_ref4","surfacesInfo","aabbs","id","aabb","cutSurfacesIntoPlanes","_ref5","updateCacheCallback","planesInfo","surfacesAABB","numberOfPlanes","cutter","vtkCutter","plane1","vtkPlane","setCutFunction","surfacePolyData","vtkPolyData","planeInfo","entries","sliceIndex","planes","polyDataResults","polyDataInfo","aabb3","has","getPoints","setData","getPolys","setInputData","setNormal","update","e","polyData","getOutputData","cutterOutput","buildLinks","loopExtraction","vtkContourLoopExtraction","loopOutput","lines","getLines","numberOfCells","getNumberOfCells","progress","delete","expose","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","__webpack_exports__","O","chunkIds","fn","priority","notFulfilled","fulfilled","Object","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","f","chunkId","reduce","u","g","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop"],"sourceRoot":""}